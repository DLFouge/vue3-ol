import {
  VectorEventType_default
} from "./chunk-X5H7V2WG.js";
import {
  BaseVector_default
} from "./chunk-Y4UODQ4X.js";
import {
  Layer_default
} from "./chunk-RELS262I.js";
import {
  ViewHint_default
} from "./chunk-4J5GOOLB.js";
import {
  EventType_default,
  Event_default,
  Property_default
} from "./chunk-TBAL5KHY.js";
import {
  apply,
  compose,
  create,
  makeInverse,
  multiply,
  reset,
  rotate,
  scale
} from "./chunk-HQZSRF55.js";
import {
  SAFARI_BUG_237906
} from "./chunk-22ZMPUOM.js";
import {
  GeometryType_default
} from "./chunk-BV5TMHXH.js";
import {
  Disposable_default,
  listen,
  unlistenByKey
} from "./chunk-POSIMZXH.js";
import {
  assign,
  clear
} from "./chunk-65SWW77D.js";
import {
  buffer,
  containsCoordinate,
  createEmpty,
  equals as equals2
} from "./chunk-4LIZYYTK.js";
import {
  equals
} from "./chunk-6G6NVFIA.js";
import {
  assert,
  getUid
} from "./chunk-2WYEPIST.js";

// node_modules/ol/webgl.js
var ARRAY_BUFFER = 34962;
var ELEMENT_ARRAY_BUFFER = 34963;
var STREAM_DRAW = 35040;
var STATIC_DRAW = 35044;
var DYNAMIC_DRAW = 35048;
var UNSIGNED_BYTE = 5121;
var UNSIGNED_SHORT = 5123;
var UNSIGNED_INT = 5125;
var FLOAT = 5126;
var CONTEXT_IDS = ["experimental-webgl", "webgl", "webkit-3d", "moz-webgl"];
function getContext(canvas, opt_attributes) {
  var attributes = assign({
    preserveDrawingBuffer: true,
    antialias: SAFARI_BUG_237906 ? false : true
  }, opt_attributes);
  var ii = CONTEXT_IDS.length;
  for (var i = 0; i < ii; ++i) {
    try {
      var context = canvas.getContext(CONTEXT_IDS[i], attributes);
      if (context) {
        return context;
      }
    } catch (e) {
    }
  }
  return null;
}

// node_modules/ol/webgl/Buffer.js
var BufferUsage = {
  STATIC_DRAW,
  STREAM_DRAW,
  DYNAMIC_DRAW
};
var WebGLArrayBuffer = function() {
  function WebGLArrayBuffer2(type, opt_usage) {
    this.array = null;
    this.type = type;
    assert(type === ARRAY_BUFFER || type === ELEMENT_ARRAY_BUFFER, 62);
    this.usage = opt_usage !== void 0 ? opt_usage : BufferUsage.STATIC_DRAW;
  }
  WebGLArrayBuffer2.prototype.ofSize = function(size) {
    this.array = new (getArrayClassForType(this.type))(size);
  };
  WebGLArrayBuffer2.prototype.fromArray = function(array) {
    var arrayClass = getArrayClassForType(this.type);
    this.array = arrayClass.from ? arrayClass.from(array) : new arrayClass(array);
  };
  WebGLArrayBuffer2.prototype.fromArrayBuffer = function(buffer2) {
    this.array = new (getArrayClassForType(this.type))(buffer2);
  };
  WebGLArrayBuffer2.prototype.getType = function() {
    return this.type;
  };
  WebGLArrayBuffer2.prototype.getArray = function() {
    return this.array;
  };
  WebGLArrayBuffer2.prototype.getUsage = function() {
    return this.usage;
  };
  WebGLArrayBuffer2.prototype.getSize = function() {
    return this.array ? this.array.length : 0;
  };
  return WebGLArrayBuffer2;
}();
function getArrayClassForType(type) {
  switch (type) {
    case ARRAY_BUFFER:
      return Float32Array;
    case ELEMENT_ARRAY_BUFFER:
      return Uint32Array;
    default:
      return Float32Array;
  }
}
var Buffer_default = WebGLArrayBuffer;

// node_modules/ol/webgl/ContextEventType.js
var ContextEventType_default = {
  LOST: "webglcontextlost",
  RESTORED: "webglcontextrestored"
};

// node_modules/ol/webgl/PostProcessingPass.js
var DEFAULT_VERTEX_SHADER = "\n  precision mediump float;\n  \n  attribute vec2 a_position;\n  varying vec2 v_texCoord;\n  varying vec2 v_screenCoord;\n  \n  uniform vec2 u_screenSize;\n   \n  void main() {\n    v_texCoord = a_position * 0.5 + 0.5;\n    v_screenCoord = v_texCoord * u_screenSize;\n    gl_Position = vec4(a_position, 0.0, 1.0);\n  }\n";
var DEFAULT_FRAGMENT_SHADER = "\n  precision mediump float;\n   \n  uniform sampler2D u_image;\n  uniform float u_opacity;\n   \n  varying vec2 v_texCoord;\n   \n  void main() {\n    gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;\n  }\n";
var WebGLPostProcessingPass = function() {
  function WebGLPostProcessingPass2(options) {
    this.gl_ = options.webGlContext;
    var gl = this.gl_;
    this.scaleRatio_ = options.scaleRatio || 1;
    this.renderTargetTexture_ = gl.createTexture();
    this.renderTargetTextureSize_ = null;
    this.frameBuffer_ = gl.createFramebuffer();
    var vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, options.vertexShader || DEFAULT_VERTEX_SHADER);
    gl.compileShader(vertexShader);
    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, options.fragmentShader || DEFAULT_FRAGMENT_SHADER);
    gl.compileShader(fragmentShader);
    this.renderTargetProgram_ = gl.createProgram();
    gl.attachShader(this.renderTargetProgram_, vertexShader);
    gl.attachShader(this.renderTargetProgram_, fragmentShader);
    gl.linkProgram(this.renderTargetProgram_);
    this.renderTargetVerticesBuffer_ = gl.createBuffer();
    var verticesArray = [-1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1];
    gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesArray), gl.STATIC_DRAW);
    this.renderTargetAttribLocation_ = gl.getAttribLocation(this.renderTargetProgram_, "a_position");
    this.renderTargetUniformLocation_ = gl.getUniformLocation(this.renderTargetProgram_, "u_screenSize");
    this.renderTargetOpacityLocation_ = gl.getUniformLocation(this.renderTargetProgram_, "u_opacity");
    this.renderTargetTextureLocation_ = gl.getUniformLocation(this.renderTargetProgram_, "u_image");
    this.uniforms_ = [];
    options.uniforms && Object.keys(options.uniforms).forEach(function(name) {
      this.uniforms_.push({
        value: options.uniforms[name],
        location: gl.getUniformLocation(this.renderTargetProgram_, name)
      });
    }.bind(this));
  }
  WebGLPostProcessingPass2.prototype.getGL = function() {
    return this.gl_;
  };
  WebGLPostProcessingPass2.prototype.init = function(frameState) {
    var gl = this.getGL();
    var textureSize = [
      gl.drawingBufferWidth * this.scaleRatio_,
      gl.drawingBufferHeight * this.scaleRatio_
    ];
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.getFrameBuffer());
    gl.viewport(0, 0, textureSize[0], textureSize[1]);
    if (!this.renderTargetTextureSize_ || this.renderTargetTextureSize_[0] !== textureSize[0] || this.renderTargetTextureSize_[1] !== textureSize[1]) {
      this.renderTargetTextureSize_ = textureSize;
      var level = 0;
      var internalFormat = gl.RGBA;
      var border = 0;
      var format = gl.RGBA;
      var type = gl.UNSIGNED_BYTE;
      var data = null;
      gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_);
      gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, textureSize[0], textureSize[1], border, format, type, data);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.renderTargetTexture_, 0);
    }
  };
  WebGLPostProcessingPass2.prototype.apply = function(frameState, nextPass, preCompose, postCompose) {
    var gl = this.getGL();
    var size = frameState.size;
    gl.bindFramebuffer(gl.FRAMEBUFFER, nextPass ? nextPass.getFrameBuffer() : null);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_);
    if (!nextPass) {
      var canvasId = getUid(gl.canvas);
      if (!frameState.renderTargets[canvasId]) {
        var attributes = gl.getContextAttributes();
        if (attributes && attributes.preserveDrawingBuffer) {
          gl.clearColor(0, 0, 0, 0);
          gl.clear(gl.COLOR_BUFFER_BIT);
        }
        frameState.renderTargets[canvasId] = true;
      }
    }
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);
    gl.useProgram(this.renderTargetProgram_);
    gl.enableVertexAttribArray(this.renderTargetAttribLocation_);
    gl.vertexAttribPointer(this.renderTargetAttribLocation_, 2, gl.FLOAT, false, 0, 0);
    gl.uniform2f(this.renderTargetUniformLocation_, size[0], size[1]);
    gl.uniform1i(this.renderTargetTextureLocation_, 0);
    var opacity = frameState.layerStatesArray[frameState.layerIndex].opacity;
    gl.uniform1f(this.renderTargetOpacityLocation_, opacity);
    this.applyUniforms(frameState);
    if (preCompose) {
      preCompose(gl, frameState);
    }
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    if (postCompose) {
      postCompose(gl, frameState);
    }
  };
  WebGLPostProcessingPass2.prototype.getFrameBuffer = function() {
    return this.frameBuffer_;
  };
  WebGLPostProcessingPass2.prototype.applyUniforms = function(frameState) {
    var gl = this.getGL();
    var value;
    var textureSlot = 1;
    this.uniforms_.forEach(function(uniform) {
      value = typeof uniform.value === "function" ? uniform.value(frameState) : uniform.value;
      if (value instanceof HTMLCanvasElement || value instanceof ImageData) {
        if (!uniform.texture) {
          uniform.texture = gl.createTexture();
        }
        gl.activeTexture(gl["TEXTURE".concat(textureSlot)]);
        gl.bindTexture(gl.TEXTURE_2D, uniform.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        if (value instanceof ImageData) {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, value.width, value.height, 0, gl.UNSIGNED_BYTE, new Uint8Array(value.data));
        } else {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, value);
        }
        gl.uniform1i(uniform.location, textureSlot++);
      } else if (Array.isArray(value)) {
        switch (value.length) {
          case 2:
            gl.uniform2f(uniform.location, value[0], value[1]);
            return;
          case 3:
            gl.uniform3f(uniform.location, value[0], value[1], value[2]);
            return;
          case 4:
            gl.uniform4f(uniform.location, value[0], value[1], value[2], value[3]);
            return;
          default:
            return;
        }
      } else if (typeof value === "number") {
        gl.uniform1f(uniform.location, value);
      }
    });
  };
  return WebGLPostProcessingPass2;
}();
var PostProcessingPass_default = WebGLPostProcessingPass;

// node_modules/ol/vec/mat4.js
function create2() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function fromTransform(mat4, transform) {
  mat4[0] = transform[0];
  mat4[1] = transform[1];
  mat4[4] = transform[2];
  mat4[5] = transform[3];
  mat4[12] = transform[4];
  mat4[13] = transform[5];
  return mat4;
}

// node_modules/ol/webgl/Helper.js
var __extends = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var DefaultUniform = {
  PROJECTION_MATRIX: "u_projectionMatrix",
  OFFSET_SCALE_MATRIX: "u_offsetScaleMatrix",
  OFFSET_ROTATION_MATRIX: "u_offsetRotateMatrix",
  TIME: "u_time",
  ZOOM: "u_zoom",
  RESOLUTION: "u_resolution"
};
var AttributeType = {
  UNSIGNED_BYTE,
  UNSIGNED_SHORT,
  UNSIGNED_INT,
  FLOAT
};
var canvasCache = {};
function getSharedCanvasCacheKey(key) {
  return "shared/" + key;
}
var uniqueCanvasCacheKeyCount = 0;
function getUniqueCanvasCacheKey() {
  var key = "unique/" + uniqueCanvasCacheKeyCount;
  uniqueCanvasCacheKeyCount += 1;
  return key;
}
function getCanvas(key) {
  var cacheItem = canvasCache[key];
  if (!cacheItem) {
    var canvas = document.createElement("canvas");
    canvas.style.position = "absolute";
    canvas.style.left = "0";
    cacheItem = { users: 0, canvas };
    canvasCache[key] = cacheItem;
  }
  cacheItem.users += 1;
  return cacheItem.canvas;
}
function releaseCanvas(key) {
  var cacheItem = canvasCache[key];
  if (!cacheItem) {
    return;
  }
  cacheItem.users -= 1;
  if (cacheItem.users > 0) {
    return;
  }
  var canvas = cacheItem.canvas;
  var gl = getContext(canvas);
  var extension = gl.getExtension("WEBGL_lose_context");
  if (extension) {
    extension.loseContext();
  }
  delete canvasCache[key];
}
var WebGLHelper = function(_super) {
  __extends(WebGLHelper2, _super);
  function WebGLHelper2(opt_options) {
    var _this = _super.call(this) || this;
    var options = opt_options || {};
    _this.boundHandleWebGLContextLost_ = _this.handleWebGLContextLost.bind(_this);
    _this.boundHandleWebGLContextRestored_ = _this.handleWebGLContextRestored.bind(_this);
    _this.canvasCacheKey_ = options.canvasCacheKey ? getSharedCanvasCacheKey(options.canvasCacheKey) : getUniqueCanvasCacheKey();
    _this.canvas_ = getCanvas(_this.canvasCacheKey_);
    _this.gl_ = getContext(_this.canvas_);
    _this.bufferCache_ = {};
    _this.extensionCache_ = {};
    _this.currentProgram_ = null;
    _this.canvas_.addEventListener(ContextEventType_default.LOST, _this.boundHandleWebGLContextLost_);
    _this.canvas_.addEventListener(ContextEventType_default.RESTORED, _this.boundHandleWebGLContextRestored_);
    _this.offsetRotateMatrix_ = create();
    _this.offsetScaleMatrix_ = create();
    _this.tmpMat4_ = create2();
    _this.uniformLocations_ = {};
    _this.attribLocations_ = {};
    _this.uniforms_ = [];
    if (options.uniforms) {
      _this.setUniforms(options.uniforms);
    }
    var gl = _this.getGL();
    _this.postProcessPasses_ = options.postProcesses ? options.postProcesses.map(function(options2) {
      return new PostProcessingPass_default({
        webGlContext: gl,
        scaleRatio: options2.scaleRatio,
        vertexShader: options2.vertexShader,
        fragmentShader: options2.fragmentShader,
        uniforms: options2.uniforms
      });
    }) : [new PostProcessingPass_default({ webGlContext: gl })];
    _this.shaderCompileErrors_ = null;
    _this.startTime_ = Date.now();
    return _this;
  }
  WebGLHelper2.prototype.setUniforms = function(uniforms) {
    this.uniforms_ = [];
    for (var name_1 in uniforms) {
      this.uniforms_.push({
        name: name_1,
        value: uniforms[name_1]
      });
    }
    this.uniformLocations_ = {};
  };
  WebGLHelper2.prototype.canvasCacheKeyMatches = function(canvasCacheKey) {
    return this.canvasCacheKey_ === getSharedCanvasCacheKey(canvasCacheKey);
  };
  WebGLHelper2.prototype.getExtension = function(name) {
    if (name in this.extensionCache_) {
      return this.extensionCache_[name];
    }
    var extension = this.gl_.getExtension(name);
    this.extensionCache_[name] = extension;
    return extension;
  };
  WebGLHelper2.prototype.bindBuffer = function(buffer2) {
    var gl = this.getGL();
    var bufferKey = getUid(buffer2);
    var bufferCache = this.bufferCache_[bufferKey];
    if (!bufferCache) {
      var webGlBuffer = gl.createBuffer();
      bufferCache = {
        buffer: buffer2,
        webGlBuffer
      };
      this.bufferCache_[bufferKey] = bufferCache;
    }
    gl.bindBuffer(buffer2.getType(), bufferCache.webGlBuffer);
  };
  WebGLHelper2.prototype.flushBufferData = function(buffer2) {
    var gl = this.getGL();
    this.bindBuffer(buffer2);
    gl.bufferData(buffer2.getType(), buffer2.getArray(), buffer2.getUsage());
  };
  WebGLHelper2.prototype.deleteBuffer = function(buf) {
    var gl = this.getGL();
    var bufferKey = getUid(buf);
    var bufferCacheEntry = this.bufferCache_[bufferKey];
    if (bufferCacheEntry && !gl.isContextLost()) {
      gl.deleteBuffer(bufferCacheEntry.webGlBuffer);
    }
    delete this.bufferCache_[bufferKey];
  };
  WebGLHelper2.prototype.disposeInternal = function() {
    this.canvas_.removeEventListener(ContextEventType_default.LOST, this.boundHandleWebGLContextLost_);
    this.canvas_.removeEventListener(ContextEventType_default.RESTORED, this.boundHandleWebGLContextRestored_);
    releaseCanvas(this.canvasCacheKey_);
    delete this.gl_;
    delete this.canvas_;
  };
  WebGLHelper2.prototype.prepareDraw = function(frameState, opt_disableAlphaBlend) {
    var gl = this.getGL();
    var canvas = this.getCanvas();
    var size = frameState.size;
    var pixelRatio = frameState.pixelRatio;
    canvas.width = size[0] * pixelRatio;
    canvas.height = size[1] * pixelRatio;
    canvas.style.width = size[0] + "px";
    canvas.style.height = size[1] + "px";
    gl.useProgram(this.currentProgram_);
    for (var i = this.postProcessPasses_.length - 1; i >= 0; i--) {
      this.postProcessPasses_[i].init(frameState);
    }
    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.ONE, opt_disableAlphaBlend ? gl.ZERO : gl.ONE_MINUS_SRC_ALPHA);
    gl.useProgram(this.currentProgram_);
    this.applyFrameState(frameState);
    this.applyUniforms(frameState);
  };
  WebGLHelper2.prototype.prepareDrawToRenderTarget = function(frameState, renderTarget, opt_disableAlphaBlend) {
    var gl = this.getGL();
    var size = renderTarget.getSize();
    gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget.getFramebuffer());
    gl.viewport(0, 0, size[0], size[1]);
    gl.bindTexture(gl.TEXTURE_2D, renderTarget.getTexture());
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.ONE, opt_disableAlphaBlend ? gl.ZERO : gl.ONE_MINUS_SRC_ALPHA);
    gl.useProgram(this.currentProgram_);
    this.applyFrameState(frameState);
    this.applyUniforms(frameState);
  };
  WebGLHelper2.prototype.drawElements = function(start, end) {
    var gl = this.getGL();
    this.getExtension("OES_element_index_uint");
    var elementType = gl.UNSIGNED_INT;
    var elementSize = 4;
    var numItems = end - start;
    var offsetInBytes = start * elementSize;
    gl.drawElements(gl.TRIANGLES, numItems, elementType, offsetInBytes);
  };
  WebGLHelper2.prototype.finalizeDraw = function(frameState, preCompose, postCompose) {
    for (var i = 0, ii = this.postProcessPasses_.length; i < ii; i++) {
      if (i === ii - 1) {
        this.postProcessPasses_[i].apply(frameState, null, preCompose, postCompose);
      } else {
        this.postProcessPasses_[i].apply(frameState, this.postProcessPasses_[i + 1]);
      }
    }
  };
  WebGLHelper2.prototype.getCanvas = function() {
    return this.canvas_;
  };
  WebGLHelper2.prototype.getGL = function() {
    return this.gl_;
  };
  WebGLHelper2.prototype.applyFrameState = function(frameState) {
    var size = frameState.size;
    var rotation = frameState.viewState.rotation;
    var offsetScaleMatrix = reset(this.offsetScaleMatrix_);
    scale(offsetScaleMatrix, 2 / size[0], 2 / size[1]);
    var offsetRotateMatrix = reset(this.offsetRotateMatrix_);
    if (rotation !== 0) {
      rotate(offsetRotateMatrix, -rotation);
    }
    this.setUniformMatrixValue(DefaultUniform.OFFSET_SCALE_MATRIX, fromTransform(this.tmpMat4_, offsetScaleMatrix));
    this.setUniformMatrixValue(DefaultUniform.OFFSET_ROTATION_MATRIX, fromTransform(this.tmpMat4_, offsetRotateMatrix));
    this.setUniformFloatValue(DefaultUniform.TIME, (Date.now() - this.startTime_) * 1e-3);
    this.setUniformFloatValue(DefaultUniform.ZOOM, frameState.viewState.zoom);
    this.setUniformFloatValue(DefaultUniform.RESOLUTION, frameState.viewState.resolution);
  };
  WebGLHelper2.prototype.applyUniforms = function(frameState) {
    var gl = this.getGL();
    var value;
    var textureSlot = 0;
    this.uniforms_.forEach(function(uniform) {
      value = typeof uniform.value === "function" ? uniform.value(frameState) : uniform.value;
      if (value instanceof HTMLCanvasElement || value instanceof HTMLImageElement || value instanceof ImageData) {
        if (!uniform.texture) {
          uniform.prevValue = void 0;
          uniform.texture = gl.createTexture();
        }
        gl.activeTexture(gl["TEXTURE".concat(textureSlot)]);
        gl.bindTexture(gl.TEXTURE_2D, uniform.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        var imageReady = !(value instanceof HTMLImageElement) || value.complete;
        if (imageReady && uniform.prevValue !== value) {
          uniform.prevValue = value;
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, value);
        }
        gl.uniform1i(this.getUniformLocation(uniform.name), textureSlot++);
      } else if (Array.isArray(value) && value.length === 6) {
        this.setUniformMatrixValue(uniform.name, fromTransform(this.tmpMat4_, value));
      } else if (Array.isArray(value) && value.length <= 4) {
        switch (value.length) {
          case 2:
            gl.uniform2f(this.getUniformLocation(uniform.name), value[0], value[1]);
            return;
          case 3:
            gl.uniform3f(this.getUniformLocation(uniform.name), value[0], value[1], value[2]);
            return;
          case 4:
            gl.uniform4f(this.getUniformLocation(uniform.name), value[0], value[1], value[2], value[3]);
            return;
          default:
            return;
        }
      } else if (typeof value === "number") {
        gl.uniform1f(this.getUniformLocation(uniform.name), value);
      }
    }.bind(this));
  };
  WebGLHelper2.prototype.useProgram = function(program) {
    if (program == this.currentProgram_) {
      return false;
    } else {
      var gl = this.getGL();
      gl.useProgram(program);
      this.currentProgram_ = program;
      this.uniformLocations_ = {};
      this.attribLocations_ = {};
      return true;
    }
  };
  WebGLHelper2.prototype.compileShader = function(source, type) {
    var gl = this.getGL();
    var shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    return shader;
  };
  WebGLHelper2.prototype.getProgram = function(fragmentShaderSource, vertexShaderSource) {
    var gl = this.getGL();
    var fragmentShader = this.compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);
    var vertexShader = this.compileShader(vertexShaderSource, gl.VERTEX_SHADER);
    var program = gl.createProgram();
    gl.attachShader(program, fragmentShader);
    gl.attachShader(program, vertexShader);
    gl.linkProgram(program);
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      var message = "Fragment shader compliation failed: ".concat(gl.getShaderInfoLog(fragmentShader));
      throw new Error(message);
    }
    gl.deleteShader(fragmentShader);
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      var message = "Vertex shader compilation failed: ".concat(gl.getShaderInfoLog(vertexShader));
      throw new Error(message);
    }
    gl.deleteShader(vertexShader);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      var message = "GL program linking failed: ".concat(gl.getShaderInfoLog(vertexShader));
      throw new Error(message);
    }
    return program;
  };
  WebGLHelper2.prototype.getUniformLocation = function(name) {
    if (this.uniformLocations_[name] === void 0) {
      this.uniformLocations_[name] = this.getGL().getUniformLocation(this.currentProgram_, name);
    }
    return this.uniformLocations_[name];
  };
  WebGLHelper2.prototype.getAttributeLocation = function(name) {
    if (this.attribLocations_[name] === void 0) {
      this.attribLocations_[name] = this.getGL().getAttribLocation(this.currentProgram_, name);
    }
    return this.attribLocations_[name];
  };
  WebGLHelper2.prototype.makeProjectionTransform = function(frameState, transform) {
    var size = frameState.size;
    var rotation = frameState.viewState.rotation;
    var resolution = frameState.viewState.resolution;
    var center = frameState.viewState.center;
    reset(transform);
    compose(transform, 0, 0, 2 / (resolution * size[0]), 2 / (resolution * size[1]), -rotation, -center[0], -center[1]);
    return transform;
  };
  WebGLHelper2.prototype.setUniformFloatValue = function(uniform, value) {
    this.getGL().uniform1f(this.getUniformLocation(uniform), value);
  };
  WebGLHelper2.prototype.setUniformFloatVec4 = function(uniform, value) {
    this.getGL().uniform4fv(this.getUniformLocation(uniform), value);
  };
  WebGLHelper2.prototype.setUniformMatrixValue = function(uniform, value) {
    this.getGL().uniformMatrix4fv(this.getUniformLocation(uniform), false, value);
  };
  WebGLHelper2.prototype.enableAttributeArray_ = function(attribName, size, type, stride, offset) {
    var location = this.getAttributeLocation(attribName);
    if (location < 0) {
      return;
    }
    this.getGL().enableVertexAttribArray(location);
    this.getGL().vertexAttribPointer(location, size, type, false, stride, offset);
  };
  WebGLHelper2.prototype.enableAttributes = function(attributes) {
    var stride = computeAttributesStride(attributes);
    var offset = 0;
    for (var i = 0; i < attributes.length; i++) {
      var attr = attributes[i];
      this.enableAttributeArray_(attr.name, attr.size, attr.type || FLOAT, stride, offset);
      offset += attr.size * getByteSizeFromType(attr.type);
    }
  };
  WebGLHelper2.prototype.handleWebGLContextLost = function() {
    clear(this.bufferCache_);
    this.currentProgram_ = null;
  };
  WebGLHelper2.prototype.handleWebGLContextRestored = function() {
  };
  WebGLHelper2.prototype.createTexture = function(size, opt_data, opt_texture) {
    var gl = this.getGL();
    var texture = opt_texture || gl.createTexture();
    var level = 0;
    var internalFormat = gl.RGBA;
    var border = 0;
    var format = gl.RGBA;
    var type = gl.UNSIGNED_BYTE;
    gl.bindTexture(gl.TEXTURE_2D, texture);
    if (opt_data) {
      gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, format, type, opt_data);
    } else {
      gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, size[0], size[1], border, format, type, null);
    }
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    return texture;
  };
  return WebGLHelper2;
}(Disposable_default);
function computeAttributesStride(attributes) {
  var stride = 0;
  for (var i = 0; i < attributes.length; i++) {
    var attr = attributes[i];
    stride += attr.size * getByteSizeFromType(attr.type);
  }
  return stride;
}
function getByteSizeFromType(type) {
  switch (type) {
    case AttributeType.UNSIGNED_BYTE:
      return Uint8Array.BYTES_PER_ELEMENT;
    case AttributeType.UNSIGNED_SHORT:
      return Uint16Array.BYTES_PER_ELEMENT;
    case AttributeType.UNSIGNED_INT:
      return Uint32Array.BYTES_PER_ELEMENT;
    case AttributeType.FLOAT:
    default:
      return Float32Array.BYTES_PER_ELEMENT;
  }
}
var Helper_default = WebGLHelper;

// node_modules/ol/renderer/webgl/Layer.js
var __extends2 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var WebGLWorkerMessageType = {
  GENERATE_BUFFERS: "GENERATE_BUFFERS"
};
var WebGLLayerRenderer = function(_super) {
  __extends2(WebGLLayerRenderer2, _super);
  function WebGLLayerRenderer2(layer, opt_options) {
    var _this = _super.call(this, layer) || this;
    var options = opt_options || {};
    _this.inversePixelTransform_ = create();
    _this.pixelContext_ = null;
    _this.postProcesses_ = options.postProcesses;
    _this.uniforms_ = options.uniforms;
    _this.helper;
    layer.addChangeListener(Property_default.MAP, _this.removeHelper.bind(_this));
    _this.dispatchPreComposeEvent = _this.dispatchPreComposeEvent.bind(_this);
    _this.dispatchPostComposeEvent = _this.dispatchPostComposeEvent.bind(_this);
    return _this;
  }
  WebGLLayerRenderer2.prototype.dispatchPreComposeEvent = function(context, frameState) {
    var layer = this.getLayer();
    if (layer.hasListener(EventType_default.PRECOMPOSE)) {
      var event_1 = new Event_default(EventType_default.PRECOMPOSE, void 0, frameState, context);
      layer.dispatchEvent(event_1);
    }
  };
  WebGLLayerRenderer2.prototype.dispatchPostComposeEvent = function(context, frameState) {
    var layer = this.getLayer();
    if (layer.hasListener(EventType_default.POSTCOMPOSE)) {
      var event_2 = new Event_default(EventType_default.POSTCOMPOSE, void 0, frameState, context);
      layer.dispatchEvent(event_2);
    }
  };
  WebGLLayerRenderer2.prototype.reset = function(options) {
    this.uniforms_ = options.uniforms;
    if (this.helper) {
      this.helper.setUniforms(this.uniforms_);
    }
  };
  WebGLLayerRenderer2.prototype.removeHelper = function() {
    if (this.helper) {
      this.helper.dispose();
      delete this.helper;
    }
  };
  WebGLLayerRenderer2.prototype.prepareFrame = function(frameState) {
    if (this.getLayer().getRenderSource()) {
      var incrementGroup = true;
      var groupNumber = -1;
      var className = void 0;
      for (var i = 0, ii = frameState.layerStatesArray.length; i < ii; i++) {
        var layer = frameState.layerStatesArray[i].layer;
        var renderer = layer.getRenderer();
        if (!(renderer instanceof WebGLLayerRenderer2)) {
          incrementGroup = true;
          continue;
        }
        var layerClassName = layer.getClassName();
        if (incrementGroup || layerClassName !== className) {
          groupNumber += 1;
          incrementGroup = false;
        }
        className = layerClassName;
        if (renderer === this) {
          break;
        }
      }
      var canvasCacheKey = "map/" + frameState.mapId + "/group/" + groupNumber;
      if (!this.helper || !this.helper.canvasCacheKeyMatches(canvasCacheKey)) {
        this.removeHelper();
        this.helper = new Helper_default({
          postProcesses: this.postProcesses_,
          uniforms: this.uniforms_,
          canvasCacheKey
        });
        if (className) {
          this.helper.getCanvas().className = className;
        }
        this.afterHelperCreated();
      }
    }
    return this.prepareFrameInternal(frameState);
  };
  WebGLLayerRenderer2.prototype.afterHelperCreated = function() {
  };
  WebGLLayerRenderer2.prototype.prepareFrameInternal = function(frameState) {
    return true;
  };
  WebGLLayerRenderer2.prototype.disposeInternal = function() {
    this.removeHelper();
    _super.prototype.disposeInternal.call(this);
  };
  WebGLLayerRenderer2.prototype.dispatchRenderEvent_ = function(type, context, frameState) {
    var layer = this.getLayer();
    if (layer.hasListener(type)) {
      compose(this.inversePixelTransform_, 0, 0, frameState.pixelRatio, -frameState.pixelRatio, 0, 0, -frameState.size[1]);
      var event_3 = new Event_default(type, this.inversePixelTransform_, frameState, context);
      layer.dispatchEvent(event_3);
    }
  };
  WebGLLayerRenderer2.prototype.preRender = function(context, frameState) {
    this.dispatchRenderEvent_(EventType_default.PRERENDER, context, frameState);
  };
  WebGLLayerRenderer2.prototype.postRender = function(context, frameState) {
    this.dispatchRenderEvent_(EventType_default.POSTRENDER, context, frameState);
  };
  WebGLLayerRenderer2.prototype.getDataAtPixel = function(pixel, frameState, hitTolerance) {
    var renderPixel = apply([frameState.pixelRatio, 0, 0, frameState.pixelRatio, 0, 0], pixel.slice());
    var gl = this.helper.getGL();
    if (!gl) {
      return null;
    }
    var layer = this.getLayer();
    var layerExtent = layer.getExtent();
    if (layerExtent) {
      var renderCoordinate = apply(frameState.pixelToCoordinateTransform, pixel.slice());
      if (!containsCoordinate(layerExtent, renderCoordinate)) {
        return null;
      }
    }
    var attributes = gl.getContextAttributes();
    if (!attributes || !attributes.preserveDrawingBuffer) {
      return new Uint8Array();
    }
    var x = Math.round(renderPixel[0]);
    var y = Math.round(renderPixel[1]);
    var pixelContext = this.pixelContext_;
    if (!pixelContext) {
      var pixelCanvas = document.createElement("canvas");
      pixelCanvas.width = 1;
      pixelCanvas.height = 1;
      pixelContext = pixelCanvas.getContext("2d");
      this.pixelContext_ = pixelContext;
    }
    pixelContext.clearRect(0, 0, 1, 1);
    var data;
    try {
      pixelContext.drawImage(gl.canvas, x, y, 1, 1, 0, 0, 1, 1);
      data = pixelContext.getImageData(0, 0, 1, 1).data;
    } catch (err) {
      return data;
    }
    if (data[3] === 0) {
      return null;
    }
    return data;
  };
  return WebGLLayerRenderer2;
}(Layer_default);
function colorEncodeId(id, opt_array) {
  var array = opt_array || [];
  var radix = 256;
  var divide = radix - 1;
  array[0] = Math.floor(id / radix / radix / radix) / divide;
  array[1] = Math.floor(id / radix / radix) % radix / divide;
  array[2] = Math.floor(id / radix) % radix / divide;
  array[3] = id % radix / divide;
  return array;
}
function colorDecodeId(color) {
  var id = 0;
  var radix = 256;
  var mult = radix - 1;
  id += Math.round(color[0] * radix * radix * radix * mult);
  id += Math.round(color[1] * radix * radix * mult);
  id += Math.round(color[2] * radix * mult);
  id += Math.round(color[3] * mult);
  return id;
}
var Layer_default2 = WebGLLayerRenderer;

// node_modules/ol/webgl/RenderTarget.js
var tmpArray4 = new Uint8Array(4);
var WebGLRenderTarget = function() {
  function WebGLRenderTarget2(helper, opt_size) {
    this.helper_ = helper;
    var gl = helper.getGL();
    this.texture_ = gl.createTexture();
    this.framebuffer_ = gl.createFramebuffer();
    this.size_ = opt_size || [1, 1];
    this.data_ = new Uint8Array(0);
    this.dataCacheDirty_ = true;
    this.updateSize_();
  }
  WebGLRenderTarget2.prototype.setSize = function(size) {
    if (equals(size, this.size_)) {
      return;
    }
    this.size_[0] = size[0];
    this.size_[1] = size[1];
    this.updateSize_();
  };
  WebGLRenderTarget2.prototype.getSize = function() {
    return this.size_;
  };
  WebGLRenderTarget2.prototype.clearCachedData = function() {
    this.dataCacheDirty_ = true;
  };
  WebGLRenderTarget2.prototype.readAll = function() {
    if (this.dataCacheDirty_) {
      var size = this.size_;
      var gl = this.helper_.getGL();
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer_);
      gl.readPixels(0, 0, size[0], size[1], gl.RGBA, gl.UNSIGNED_BYTE, this.data_);
      this.dataCacheDirty_ = false;
    }
    return this.data_;
  };
  WebGLRenderTarget2.prototype.readPixel = function(x, y) {
    if (x < 0 || y < 0 || x > this.size_[0] || y >= this.size_[1]) {
      tmpArray4[0] = 0;
      tmpArray4[1] = 0;
      tmpArray4[2] = 0;
      tmpArray4[3] = 0;
      return tmpArray4;
    }
    this.readAll();
    var index = Math.floor(x) + (this.size_[1] - Math.floor(y) - 1) * this.size_[0];
    tmpArray4[0] = this.data_[index * 4];
    tmpArray4[1] = this.data_[index * 4 + 1];
    tmpArray4[2] = this.data_[index * 4 + 2];
    tmpArray4[3] = this.data_[index * 4 + 3];
    return tmpArray4;
  };
  WebGLRenderTarget2.prototype.getTexture = function() {
    return this.texture_;
  };
  WebGLRenderTarget2.prototype.getFramebuffer = function() {
    return this.framebuffer_;
  };
  WebGLRenderTarget2.prototype.updateSize_ = function() {
    var size = this.size_;
    var gl = this.helper_.getGL();
    this.texture_ = this.helper_.createTexture(size, null, this.texture_);
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer_);
    gl.viewport(0, 0, size[0], size[1]);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture_, 0);
    this.data_ = new Uint8Array(size[0] * size[1] * 4);
  };
  return WebGLRenderTarget2;
}();
var RenderTarget_default = WebGLRenderTarget;

// node_modules/ol/worker/webgl.js
function create3() {
  var source = 'var e="function"==typeof Object.assign?Object.assign:function(e,n){if(null==e)throw new TypeError("Cannot convert undefined or null to object");for(var t=Object(e),r=1,o=arguments.length;r<o;++r){var i=arguments[r];if(null!=i)for(var f in i)i.hasOwnProperty(f)&&(t[f]=i[f])}return t},n="GENERATE_BUFFERS",t=[],r={vertexPosition:0,indexPosition:0};function o(e,n,t,r,o){e[n+0]=t,e[n+1]=r,e[n+2]=o}function i(e,n,i,f,s,a){var u=3+s,l=e[n+0],v=e[n+1],c=t;c.length=s;for(var g=0;g<c.length;g++)c[g]=e[n+2+g];var b=a?a.vertexPosition:0,h=a?a.indexPosition:0,d=b/u;return o(i,b,l,v,0),c.length&&i.set(c,b+3),o(i,b+=u,l,v,1),c.length&&i.set(c,b+3),o(i,b+=u,l,v,2),c.length&&i.set(c,b+3),o(i,b+=u,l,v,3),c.length&&i.set(c,b+3),b+=u,f[h++]=d,f[h++]=d+1,f[h++]=d+3,f[h++]=d+1,f[h++]=d+2,f[h++]=d+3,r.vertexPosition=b,r.indexPosition=h,r}var f=self;f.onmessage=function(t){var r=t.data;if(r.type===n){for(var o,s=r.customAttributesCount,a=2+s,u=new Float32Array(r.renderInstructions),l=u.length/a,v=4*l*(s+3),c=new Uint32Array(6*l),g=new Float32Array(v),b=0;b<u.length;b+=a)o=i(u,b,g,c,s,o);var h=e({vertexBuffer:g.buffer,indexBuffer:c.buffer,renderInstructions:u.buffer},r);f.postMessage(h,[g.buffer,c.buffer,u.buffer])}};';
  return new Worker(typeof Blob === "undefined" ? "data:application/javascript;base64," + Buffer.from(source, "binary").toString("base64") : URL.createObjectURL(new Blob([source], { type: "application/javascript" })));
}

// node_modules/ol/renderer/webgl/PointsLayer.js
var __extends3 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var WebGLPointsLayerRenderer = function(_super) {
  __extends3(WebGLPointsLayerRenderer2, _super);
  function WebGLPointsLayerRenderer2(layer, options) {
    var _this = this;
    var uniforms = options.uniforms || {};
    var projectionMatrixTransform = create();
    uniforms[DefaultUniform.PROJECTION_MATRIX] = projectionMatrixTransform;
    _this = _super.call(this, layer, {
      uniforms,
      postProcesses: options.postProcesses
    }) || this;
    _this.ready = false;
    _this.sourceRevision_ = -1;
    _this.verticesBuffer_ = new Buffer_default(ARRAY_BUFFER, DYNAMIC_DRAW);
    _this.hitVerticesBuffer_ = new Buffer_default(ARRAY_BUFFER, DYNAMIC_DRAW);
    _this.indicesBuffer_ = new Buffer_default(ELEMENT_ARRAY_BUFFER, DYNAMIC_DRAW);
    _this.vertexShader_ = options.vertexShader;
    _this.fragmentShader_ = options.fragmentShader;
    _this.program_;
    _this.hitDetectionEnabled_ = options.hitFragmentShader && options.hitVertexShader ? true : false;
    _this.hitVertexShader_ = options.hitVertexShader;
    _this.hitFragmentShader_ = options.hitFragmentShader;
    _this.hitProgram_;
    var customAttributes = options.attributes ? options.attributes.map(function(attribute) {
      return {
        name: "a_" + attribute.name,
        size: 1,
        type: AttributeType.FLOAT
      };
    }) : [];
    _this.attributes = [
      {
        name: "a_position",
        size: 2,
        type: AttributeType.FLOAT
      },
      {
        name: "a_index",
        size: 1,
        type: AttributeType.FLOAT
      }
    ].concat(customAttributes);
    _this.hitDetectionAttributes = [
      {
        name: "a_position",
        size: 2,
        type: AttributeType.FLOAT
      },
      {
        name: "a_index",
        size: 1,
        type: AttributeType.FLOAT
      },
      {
        name: "a_hitColor",
        size: 4,
        type: AttributeType.FLOAT
      },
      {
        name: "a_featureUid",
        size: 1,
        type: AttributeType.FLOAT
      }
    ].concat(customAttributes);
    _this.customAttributes = options.attributes ? options.attributes : [];
    _this.previousExtent_ = createEmpty();
    _this.currentTransform_ = projectionMatrixTransform;
    _this.renderTransform_ = create();
    _this.invertRenderTransform_ = create();
    _this.renderInstructions_ = new Float32Array(0);
    _this.hitRenderInstructions_ = new Float32Array(0);
    _this.hitRenderTarget_;
    _this.generateBuffersRun_ = 0;
    _this.worker_ = create3();
    _this.worker_.addEventListener("message", function(event) {
      var received = event.data;
      if (received.type === WebGLWorkerMessageType.GENERATE_BUFFERS) {
        var projectionTransform = received.projectionTransform;
        if (received.hitDetection) {
          this.hitVerticesBuffer_.fromArrayBuffer(received.vertexBuffer);
          this.helper.flushBufferData(this.hitVerticesBuffer_);
        } else {
          this.verticesBuffer_.fromArrayBuffer(received.vertexBuffer);
          this.helper.flushBufferData(this.verticesBuffer_);
        }
        this.indicesBuffer_.fromArrayBuffer(received.indexBuffer);
        this.helper.flushBufferData(this.indicesBuffer_);
        this.renderTransform_ = projectionTransform;
        makeInverse(this.invertRenderTransform_, this.renderTransform_);
        if (received.hitDetection) {
          this.hitRenderInstructions_ = new Float32Array(event.data.renderInstructions);
        } else {
          this.renderInstructions_ = new Float32Array(event.data.renderInstructions);
          if (received.generateBuffersRun === this.generateBuffersRun_) {
            this.ready = true;
          }
        }
        this.getLayer().changed();
      }
    }.bind(_this));
    _this.featureCache_ = {};
    _this.featureCount_ = 0;
    var source = _this.getLayer().getSource();
    _this.sourceListenKeys_ = [
      listen(source, VectorEventType_default.ADDFEATURE, _this.handleSourceFeatureAdded_, _this),
      listen(source, VectorEventType_default.CHANGEFEATURE, _this.handleSourceFeatureChanged_, _this),
      listen(source, VectorEventType_default.REMOVEFEATURE, _this.handleSourceFeatureDelete_, _this),
      listen(source, VectorEventType_default.CLEAR, _this.handleSourceFeatureClear_, _this)
    ];
    source.forEachFeature(function(feature) {
      this.featureCache_[getUid(feature)] = {
        feature,
        properties: feature.getProperties(),
        geometry: feature.getGeometry()
      };
      this.featureCount_++;
    }.bind(_this));
    return _this;
  }
  WebGLPointsLayerRenderer2.prototype.afterHelperCreated = function() {
    this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_);
    if (this.hitDetectionEnabled_) {
      this.hitProgram_ = this.helper.getProgram(this.hitFragmentShader_, this.hitVertexShader_);
      this.hitRenderTarget_ = new RenderTarget_default(this.helper);
    }
  };
  WebGLPointsLayerRenderer2.prototype.handleSourceFeatureAdded_ = function(event) {
    var feature = event.feature;
    this.featureCache_[getUid(feature)] = {
      feature,
      properties: feature.getProperties(),
      geometry: feature.getGeometry()
    };
    this.featureCount_++;
  };
  WebGLPointsLayerRenderer2.prototype.handleSourceFeatureChanged_ = function(event) {
    var feature = event.feature;
    this.featureCache_[getUid(feature)] = {
      feature,
      properties: feature.getProperties(),
      geometry: feature.getGeometry()
    };
  };
  WebGLPointsLayerRenderer2.prototype.handleSourceFeatureDelete_ = function(event) {
    var feature = event.feature;
    delete this.featureCache_[getUid(feature)];
    this.featureCount_--;
  };
  WebGLPointsLayerRenderer2.prototype.handleSourceFeatureClear_ = function() {
    this.featureCache_ = {};
    this.featureCount_ = 0;
  };
  WebGLPointsLayerRenderer2.prototype.renderFrame = function(frameState) {
    var gl = this.helper.getGL();
    this.preRender(gl, frameState);
    var renderCount = this.indicesBuffer_.getSize();
    this.helper.drawElements(0, renderCount);
    this.helper.finalizeDraw(frameState, this.dispatchPreComposeEvent, this.dispatchPostComposeEvent);
    var canvas = this.helper.getCanvas();
    if (this.hitDetectionEnabled_) {
      this.renderHitDetection(frameState);
      this.hitRenderTarget_.clearCachedData();
    }
    this.postRender(gl, frameState);
    return canvas;
  };
  WebGLPointsLayerRenderer2.prototype.prepareFrameInternal = function(frameState) {
    var layer = this.getLayer();
    var vectorSource = layer.getSource();
    var viewState = frameState.viewState;
    var viewNotMoving = !frameState.viewHints[ViewHint_default.ANIMATING] && !frameState.viewHints[ViewHint_default.INTERACTING];
    var extentChanged = !equals2(this.previousExtent_, frameState.extent);
    var sourceChanged = this.sourceRevision_ < vectorSource.getRevision();
    if (sourceChanged) {
      this.sourceRevision_ = vectorSource.getRevision();
    }
    if (viewNotMoving && (extentChanged || sourceChanged)) {
      var projection = viewState.projection;
      var resolution = viewState.resolution;
      var renderBuffer = layer instanceof BaseVector_default ? layer.getRenderBuffer() : 0;
      var extent = buffer(frameState.extent, renderBuffer * resolution);
      vectorSource.loadFeatures(extent, resolution, projection);
      this.rebuildBuffers_(frameState);
      this.previousExtent_ = frameState.extent.slice();
    }
    this.helper.makeProjectionTransform(frameState, this.currentTransform_);
    multiply(this.currentTransform_, this.invertRenderTransform_);
    this.helper.useProgram(this.program_);
    this.helper.prepareDraw(frameState);
    this.helper.bindBuffer(this.verticesBuffer_);
    this.helper.bindBuffer(this.indicesBuffer_);
    this.helper.enableAttributes(this.attributes);
    return true;
  };
  WebGLPointsLayerRenderer2.prototype.rebuildBuffers_ = function(frameState) {
    var projectionTransform = create();
    this.helper.makeProjectionTransform(frameState, projectionTransform);
    var totalInstructionsCount = (2 + this.customAttributes.length) * this.featureCount_;
    if (!this.renderInstructions_ || this.renderInstructions_.length !== totalInstructionsCount) {
      this.renderInstructions_ = new Float32Array(totalInstructionsCount);
    }
    if (this.hitDetectionEnabled_) {
      var totalHitInstructionsCount = (7 + this.customAttributes.length) * this.featureCount_;
      if (!this.hitRenderInstructions_ || this.hitRenderInstructions_.length !== totalHitInstructionsCount) {
        this.hitRenderInstructions_ = new Float32Array(totalHitInstructionsCount);
      }
    }
    var featureCache, geometry;
    var tmpCoords = [];
    var tmpColor = [];
    var renderIndex = 0;
    var hitIndex = 0;
    var hitColor;
    for (var featureUid in this.featureCache_) {
      featureCache = this.featureCache_[featureUid];
      geometry = featureCache.geometry;
      if (!geometry || geometry.getType() !== GeometryType_default.POINT) {
        continue;
      }
      tmpCoords[0] = geometry.getFlatCoordinates()[0];
      tmpCoords[1] = geometry.getFlatCoordinates()[1];
      apply(projectionTransform, tmpCoords);
      hitColor = colorEncodeId(hitIndex + 6, tmpColor);
      this.renderInstructions_[renderIndex++] = tmpCoords[0];
      this.renderInstructions_[renderIndex++] = tmpCoords[1];
      if (this.hitDetectionEnabled_) {
        this.hitRenderInstructions_[hitIndex++] = tmpCoords[0];
        this.hitRenderInstructions_[hitIndex++] = tmpCoords[1];
        this.hitRenderInstructions_[hitIndex++] = hitColor[0];
        this.hitRenderInstructions_[hitIndex++] = hitColor[1];
        this.hitRenderInstructions_[hitIndex++] = hitColor[2];
        this.hitRenderInstructions_[hitIndex++] = hitColor[3];
        this.hitRenderInstructions_[hitIndex++] = Number(featureUid);
      }
      var value = void 0;
      for (var j = 0; j < this.customAttributes.length; j++) {
        value = this.customAttributes[j].callback(featureCache.feature, featureCache.properties);
        this.renderInstructions_[renderIndex++] = value;
        if (this.hitDetectionEnabled_) {
          this.hitRenderInstructions_[hitIndex++] = value;
        }
      }
    }
    var message = {
      type: WebGLWorkerMessageType.GENERATE_BUFFERS,
      renderInstructions: this.renderInstructions_.buffer,
      customAttributesCount: this.customAttributes.length
    };
    message["projectionTransform"] = projectionTransform;
    message["generateBuffersRun"] = ++this.generateBuffersRun_;
    this.ready = false;
    this.worker_.postMessage(message, [this.renderInstructions_.buffer]);
    this.renderInstructions_ = null;
    if (this.hitDetectionEnabled_) {
      var hitMessage = {
        type: WebGLWorkerMessageType.GENERATE_BUFFERS,
        renderInstructions: this.hitRenderInstructions_.buffer,
        customAttributesCount: 5 + this.customAttributes.length
      };
      hitMessage["projectionTransform"] = projectionTransform;
      hitMessage["hitDetection"] = true;
      this.worker_.postMessage(hitMessage, [
        this.hitRenderInstructions_.buffer
      ]);
      this.hitRenderInstructions_ = null;
    }
  };
  WebGLPointsLayerRenderer2.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, callback, matches) {
    assert(this.hitDetectionEnabled_, 66);
    if (!this.hitRenderInstructions_) {
      return void 0;
    }
    var pixel = apply(frameState.coordinateToPixelTransform, coordinate.slice());
    var data = this.hitRenderTarget_.readPixel(pixel[0] / 2, pixel[1] / 2);
    var color = [data[0] / 255, data[1] / 255, data[2] / 255, data[3] / 255];
    var index = colorDecodeId(color);
    var opacity = this.hitRenderInstructions_[index];
    var uid = Math.floor(opacity).toString();
    var source = this.getLayer().getSource();
    var feature = source.getFeatureByUid(uid);
    if (feature) {
      return callback(feature, this.getLayer(), null);
    }
    return void 0;
  };
  WebGLPointsLayerRenderer2.prototype.renderHitDetection = function(frameState) {
    if (!this.hitVerticesBuffer_.getSize()) {
      return;
    }
    this.hitRenderTarget_.setSize([
      Math.floor(frameState.size[0] / 2),
      Math.floor(frameState.size[1] / 2)
    ]);
    this.helper.useProgram(this.hitProgram_);
    this.helper.prepareDrawToRenderTarget(frameState, this.hitRenderTarget_, true);
    this.helper.bindBuffer(this.hitVerticesBuffer_);
    this.helper.bindBuffer(this.indicesBuffer_);
    this.helper.enableAttributes(this.hitDetectionAttributes);
    var renderCount = this.indicesBuffer_.getSize();
    this.helper.drawElements(0, renderCount);
  };
  WebGLPointsLayerRenderer2.prototype.disposeInternal = function() {
    this.worker_.terminate();
    this.layer_ = null;
    this.sourceListenKeys_.forEach(function(key) {
      unlistenByKey(key);
    });
    this.sourceListenKeys_ = null;
    _super.prototype.disposeInternal.call(this);
  };
  return WebGLPointsLayerRenderer2;
}(Layer_default2);
var PointsLayer_default = WebGLPointsLayerRenderer;

export {
  ARRAY_BUFFER,
  ELEMENT_ARRAY_BUFFER,
  STATIC_DRAW,
  Buffer_default,
  create2 as create,
  fromTransform,
  AttributeType,
  Layer_default2 as Layer_default,
  PointsLayer_default
};
//# sourceMappingURL=chunk-XO5TAQGF.js.map
