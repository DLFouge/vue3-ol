import {
  TileLayer_default,
  TileProperty_default
} from "./chunk-E5GLDD3O.js";
import {
  BuilderGroup_default,
  ExecutorGroup_default,
  HIT_DETECT_RESOLUTION,
  createHitDetectionImageData,
  hitDetect
} from "./chunk-DNZESCKH.js";
import {
  BuilderType_default,
  getSquaredTolerance,
  renderFeature
} from "./chunk-RBDOL7K2.js";
import {
  BaseVector_default
} from "./chunk-Y4UODQ4X.js";
import {
  TileState_default
} from "./chunk-TTYWGBB4.js";
import {
  toSize
} from "./chunk-52GDN6Z5.js";
import {
  ViewHint_default
} from "./chunk-4J5GOOLB.js";
import {
  wrapX
} from "./chunk-SXHM4DXD.js";
import {
  apply,
  create,
  multiply,
  reset,
  scale,
  translate
} from "./chunk-HQZSRF55.js";
import {
  assign
} from "./chunk-65SWW77D.js";
import {
  boundingExtent,
  buffer,
  containsExtent,
  equals,
  getIntersection,
  getTopLeft,
  intersects
} from "./chunk-4LIZYYTK.js";
import {
  assert,
  getUid
} from "./chunk-2WYEPIST.js";

// node_modules/ol/layer/VectorTileRenderType.js
var VectorTileRenderType_default = {
  IMAGE: "image",
  HYBRID: "hybrid",
  VECTOR: "vector"
};

// node_modules/ol/renderer/canvas/VectorTileLayer.js
var __extends = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var IMAGE_REPLAYS = {
  "image": [
    BuilderType_default.POLYGON,
    BuilderType_default.CIRCLE,
    BuilderType_default.LINE_STRING,
    BuilderType_default.IMAGE,
    BuilderType_default.TEXT
  ],
  "hybrid": [BuilderType_default.POLYGON, BuilderType_default.LINE_STRING],
  "vector": []
};
var VECTOR_REPLAYS = {
  "hybrid": [BuilderType_default.IMAGE, BuilderType_default.TEXT, BuilderType_default.DEFAULT],
  "vector": [
    BuilderType_default.POLYGON,
    BuilderType_default.CIRCLE,
    BuilderType_default.LINE_STRING,
    BuilderType_default.IMAGE,
    BuilderType_default.TEXT,
    BuilderType_default.DEFAULT
  ]
};
var CanvasVectorTileLayerRenderer = function(_super) {
  __extends(CanvasVectorTileLayerRenderer2, _super);
  function CanvasVectorTileLayerRenderer2(layer) {
    var _this = _super.call(this, layer) || this;
    _this.boundHandleStyleImageChange_ = _this.handleStyleImageChange_.bind(_this);
    _this.dirty_ = false;
    _this.renderedLayerRevision_;
    _this.renderedPixelToCoordinateTransform_ = null;
    _this.renderedRotation_;
    _this.tmpTransform_ = create();
    return _this;
  }
  CanvasVectorTileLayerRenderer2.prototype.prepareTile = function(tile, pixelRatio, projection) {
    var render;
    var state = tile.getState();
    if (state === TileState_default.LOADED || state === TileState_default.ERROR) {
      this.updateExecutorGroup_(tile, pixelRatio, projection);
      if (this.tileImageNeedsRender_(tile)) {
        render = true;
      }
    }
    return render;
  };
  CanvasVectorTileLayerRenderer2.prototype.getTile = function(z, x, y, frameState) {
    var pixelRatio = frameState.pixelRatio;
    var viewState = frameState.viewState;
    var resolution = viewState.resolution;
    var projection = viewState.projection;
    var layer = this.getLayer();
    var tile = layer.getSource().getTile(z, x, y, pixelRatio, projection);
    var viewHints = frameState.viewHints;
    var hifi = !(viewHints[ViewHint_default.ANIMATING] || viewHints[ViewHint_default.INTERACTING]);
    if (hifi || !tile.wantedResolution) {
      tile.wantedResolution = resolution;
    }
    var render = this.prepareTile(tile, pixelRatio, projection);
    if (render && (hifi || Date.now() - frameState.time < 8) && layer.getRenderMode() !== VectorTileRenderType_default.VECTOR) {
      this.renderTileImage_(tile, frameState);
    }
    return _super.prototype.getTile.call(this, z, x, y, frameState);
  };
  CanvasVectorTileLayerRenderer2.prototype.isDrawableTile = function(tile) {
    var layer = this.getLayer();
    return _super.prototype.isDrawableTile.call(this, tile) && (layer.getRenderMode() === VectorTileRenderType_default.VECTOR ? getUid(layer) in tile.executorGroups : tile.hasContext(layer));
  };
  CanvasVectorTileLayerRenderer2.prototype.getTileImage = function(tile) {
    return tile.getImage(this.getLayer());
  };
  CanvasVectorTileLayerRenderer2.prototype.prepareFrame = function(frameState) {
    var layerRevision = this.getLayer().getRevision();
    if (this.renderedLayerRevision_ != layerRevision) {
      this.renderedTiles.length = 0;
    }
    this.renderedLayerRevision_ = layerRevision;
    return _super.prototype.prepareFrame.call(this, frameState);
  };
  CanvasVectorTileLayerRenderer2.prototype.updateExecutorGroup_ = function(tile, pixelRatio, projection) {
    var layer = this.getLayer();
    var revision = layer.getRevision();
    var renderOrder = layer.getRenderOrder() || null;
    var resolution = tile.wantedResolution;
    var builderState = tile.getReplayState(layer);
    if (!builderState.dirty && builderState.renderedResolution === resolution && builderState.renderedRevision == revision && builderState.renderedRenderOrder == renderOrder) {
      return;
    }
    var source = layer.getSource();
    var declutter = layer.getDeclutter();
    var sourceTileGrid = source.getTileGrid();
    var tileGrid = source.getTileGridForProjection(projection);
    var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);
    var sourceTiles = source.getSourceTiles(pixelRatio, projection, tile);
    var layerUid = getUid(layer);
    delete tile.hitDetectionImageData[layerUid];
    tile.executorGroups[layerUid] = [];
    if (declutter) {
      tile.declutterExecutorGroups[layerUid] = [];
    }
    var _loop_1 = function(t2, tt2) {
      var sourceTile = sourceTiles[t2];
      if (sourceTile.getState() != TileState_default.LOADED) {
        return "continue";
      }
      var sourceTileCoord = sourceTile.tileCoord;
      var sourceTileExtent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);
      var sharedExtent = getIntersection(tileExtent, sourceTileExtent);
      var builderExtent = buffer(sharedExtent, layer.getRenderBuffer() * resolution, this_1.tmpExtent);
      var bufferedExtent = equals(sourceTileExtent, sharedExtent) ? null : builderExtent;
      builderState.dirty = false;
      var builderGroup = new BuilderGroup_default(0, builderExtent, resolution, pixelRatio);
      var declutterBuilderGroup = declutter ? new BuilderGroup_default(0, sharedExtent, resolution, pixelRatio) : void 0;
      var squaredTolerance = getSquaredTolerance(resolution, pixelRatio);
      var render = function(feature2) {
        var styles;
        var styleFunction = feature2.getStyleFunction() || layer.getStyleFunction();
        if (styleFunction) {
          styles = styleFunction(feature2, resolution);
        }
        if (styles) {
          var dirty = this.renderFeature(feature2, squaredTolerance, styles, builderGroup, declutterBuilderGroup);
          this.dirty_ = this.dirty_ || dirty;
          builderState.dirty = builderState.dirty || dirty;
        }
      };
      var features = sourceTile.getFeatures();
      if (renderOrder && renderOrder !== builderState.renderedRenderOrder) {
        features.sort(renderOrder);
      }
      for (var i = 0, ii = features.length; i < ii; ++i) {
        var feature = features[i];
        if (!bufferedExtent || intersects(bufferedExtent, feature.getGeometry().getExtent())) {
          render.call(this_1, feature);
        }
      }
      var executorGroupInstructions = builderGroup.finish();
      var replayExtent = layer.getRenderMode() !== VectorTileRenderType_default.VECTOR && declutter && sourceTiles.length === 1 ? null : sharedExtent;
      var renderingReplayGroup = new ExecutorGroup_default(replayExtent, resolution, pixelRatio, source.getOverlaps(), executorGroupInstructions, layer.getRenderBuffer());
      tile.executorGroups[layerUid].push(renderingReplayGroup);
      if (declutterBuilderGroup) {
        var declutterExecutorGroup = new ExecutorGroup_default(null, resolution, pixelRatio, source.getOverlaps(), declutterBuilderGroup.finish(), layer.getRenderBuffer());
        tile.declutterExecutorGroups[layerUid].push(declutterExecutorGroup);
      }
    };
    var this_1 = this;
    for (var t = 0, tt = sourceTiles.length; t < tt; ++t) {
      _loop_1(t, tt);
    }
    builderState.renderedRevision = revision;
    builderState.renderedRenderOrder = renderOrder;
    builderState.renderedResolution = resolution;
  };
  CanvasVectorTileLayerRenderer2.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, callback, matches) {
    var resolution = frameState.viewState.resolution;
    var rotation = frameState.viewState.rotation;
    hitTolerance = hitTolerance == void 0 ? 0 : hitTolerance;
    var layer = this.getLayer();
    var source = layer.getSource();
    var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);
    var hitExtent = boundingExtent([coordinate]);
    buffer(hitExtent, resolution * hitTolerance, hitExtent);
    var features = {};
    var featureCallback = function(feature, geometry, distanceSq) {
      var key = feature.getId();
      if (key === void 0) {
        key = getUid(feature);
      }
      var match = features[key];
      if (!match) {
        if (distanceSq === 0) {
          features[key] = true;
          return callback(feature, layer, geometry);
        }
        matches.push(features[key] = {
          feature,
          layer,
          geometry,
          distanceSq,
          callback
        });
      } else if (match !== true && distanceSq < match.distanceSq) {
        if (distanceSq === 0) {
          features[key] = true;
          matches.splice(matches.lastIndexOf(match), 1);
          return callback(feature, layer, geometry);
        }
        match.geometry = geometry;
        match.distanceSq = distanceSq;
      }
      return void 0;
    };
    var renderedTiles = this.renderedTiles;
    var found;
    var _loop_2 = function(i2, ii2) {
      var tile = renderedTiles[i2];
      var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);
      if (!intersects(tileExtent, hitExtent)) {
        return "continue";
      }
      var layerUid = getUid(layer);
      var executorGroups = [tile.executorGroups[layerUid]];
      var declutterExecutorGroups = tile.declutterExecutorGroups[layerUid];
      if (declutterExecutorGroups) {
        executorGroups.push(declutterExecutorGroups);
      }
      executorGroups.some(function(executorGroups2) {
        var declutteredFeatures = executorGroups2 === declutterExecutorGroups ? frameState.declutterTree.all().map(function(item) {
          return item.value;
        }) : null;
        for (var t = 0, tt = executorGroups2.length; t < tt; ++t) {
          var executorGroup = executorGroups2[t];
          found = executorGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, featureCallback, declutteredFeatures);
          if (found) {
            return true;
          }
        }
      });
    };
    for (var i = 0, ii = renderedTiles.length; !found && i < ii; ++i) {
      _loop_2(i, ii);
    }
    return found;
  };
  CanvasVectorTileLayerRenderer2.prototype.getFeatures = function(pixel) {
    return new Promise(function(resolve, reject) {
      var layer = this.getLayer();
      var layerUid = getUid(layer);
      var source = layer.getSource();
      var projection = this.renderedProjection;
      var projectionExtent = projection.getExtent();
      var resolution = this.renderedResolution;
      var tileGrid = source.getTileGridForProjection(projection);
      var coordinate = apply(this.renderedPixelToCoordinateTransform_, pixel.slice());
      var tileCoord = tileGrid.getTileCoordForCoordAndResolution(coordinate, resolution);
      var tile;
      for (var i = 0, ii = this.renderedTiles.length; i < ii; ++i) {
        if (tileCoord.toString() === this.renderedTiles[i].tileCoord.toString()) {
          tile = this.renderedTiles[i];
          if (tile.getState() === TileState_default.LOADED) {
            var extent_1 = tileGrid.getTileCoordExtent(tile.tileCoord);
            if (source.getWrapX() && projection.canWrapX() && !containsExtent(projectionExtent, extent_1)) {
              wrapX(coordinate, projection);
            }
            break;
          }
          tile = void 0;
        }
      }
      if (!tile || tile.loadingSourceTiles > 0) {
        resolve([]);
        return;
      }
      var extent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);
      var corner = getTopLeft(extent);
      var tilePixel = [
        (coordinate[0] - corner[0]) / resolution,
        (corner[1] - coordinate[1]) / resolution
      ];
      var features = tile.getSourceTiles().reduce(function(accumulator, sourceTile) {
        return accumulator.concat(sourceTile.getFeatures());
      }, []);
      var hitDetectionImageData = tile.hitDetectionImageData[layerUid];
      if (!hitDetectionImageData && !this.animatingOrInteracting_) {
        var tileSize = toSize(tileGrid.getTileSize(tileGrid.getZForResolution(resolution)));
        var rotation = this.renderedRotation_;
        var transforms = [
          this.getRenderTransform(tileGrid.getTileCoordCenter(tile.wrappedTileCoord), resolution, 0, HIT_DETECT_RESOLUTION, tileSize[0] * HIT_DETECT_RESOLUTION, tileSize[1] * HIT_DETECT_RESOLUTION, 0)
        ];
        hitDetectionImageData = createHitDetectionImageData(tileSize, transforms, features, layer.getStyleFunction(), tileGrid.getTileCoordExtent(tile.wrappedTileCoord), tile.getReplayState(layer).renderedResolution, rotation);
        tile.hitDetectionImageData[layerUid] = hitDetectionImageData;
      }
      resolve(hitDetect(tilePixel, features, hitDetectionImageData));
    }.bind(this));
  };
  CanvasVectorTileLayerRenderer2.prototype.handleFontsChanged = function() {
    var layer = this.getLayer();
    if (layer.getVisible() && this.renderedLayerRevision_ !== void 0) {
      layer.changed();
    }
  };
  CanvasVectorTileLayerRenderer2.prototype.handleStyleImageChange_ = function(event) {
    this.renderIfReadyAndVisible();
  };
  CanvasVectorTileLayerRenderer2.prototype.renderDeclutter = function(frameState) {
    var context = this.context;
    var alpha = context.globalAlpha;
    context.globalAlpha = this.getLayer().getOpacity();
    var viewHints = frameState.viewHints;
    var hifi = !(viewHints[ViewHint_default.ANIMATING] || viewHints[ViewHint_default.INTERACTING]);
    var tiles = this.renderedTiles;
    for (var i = 0, ii = tiles.length; i < ii; ++i) {
      var tile = tiles[i];
      var declutterExecutorGroups = tile.declutterExecutorGroups[getUid(this.getLayer())];
      if (declutterExecutorGroups) {
        for (var j = declutterExecutorGroups.length - 1; j >= 0; --j) {
          declutterExecutorGroups[j].execute(this.context, 1, this.getTileRenderTransform(tile, frameState), frameState.viewState.rotation, hifi, void 0, frameState.declutterTree);
        }
      }
    }
    context.globalAlpha = alpha;
  };
  CanvasVectorTileLayerRenderer2.prototype.getTileRenderTransform = function(tile, frameState) {
    var pixelRatio = frameState.pixelRatio;
    var viewState = frameState.viewState;
    var center = viewState.center;
    var resolution = viewState.resolution;
    var rotation = viewState.rotation;
    var size = frameState.size;
    var width = Math.round(size[0] * pixelRatio);
    var height = Math.round(size[1] * pixelRatio);
    var source = this.getLayer().getSource();
    var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);
    var tileCoord = tile.tileCoord;
    var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);
    var worldOffset = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent)[0] - tileExtent[0];
    var transform = multiply(scale(this.inversePixelTransform.slice(), 1 / pixelRatio, 1 / pixelRatio), this.getRenderTransform(center, resolution, rotation, pixelRatio, width, height, worldOffset));
    return transform;
  };
  CanvasVectorTileLayerRenderer2.prototype.renderFrame = function(frameState, target) {
    var viewHints = frameState.viewHints;
    var hifi = !(viewHints[ViewHint_default.ANIMATING] || viewHints[ViewHint_default.INTERACTING]);
    _super.prototype.renderFrame.call(this, frameState, target);
    this.renderedPixelToCoordinateTransform_ = frameState.pixelToCoordinateTransform.slice();
    this.renderedRotation_ = frameState.viewState.rotation;
    var layer = this.getLayer();
    var renderMode = layer.getRenderMode();
    var context = this.context;
    var alpha = context.globalAlpha;
    context.globalAlpha = layer.getOpacity();
    var replayTypes = VECTOR_REPLAYS[renderMode];
    var viewState = frameState.viewState;
    var rotation = viewState.rotation;
    var tileSource = layer.getSource();
    var tileGrid = tileSource.getTileGridForProjection(viewState.projection);
    var z = tileGrid.getZForResolution(viewState.resolution, tileSource.zDirection);
    var tiles = this.renderedTiles;
    var clips = [];
    var clipZs = [];
    for (var i = tiles.length - 1; i >= 0; --i) {
      var tile = tiles[i];
      var executorGroups = tile.executorGroups[getUid(layer)].filter(function(group) {
        return group.hasExecutors(replayTypes);
      });
      if (executorGroups.length === 0) {
        continue;
      }
      var transform = this.getTileRenderTransform(tile, frameState);
      var currentZ = tile.tileCoord[0];
      var contextSaved = false;
      var currentClip = executorGroups[0].getClipCoords(transform);
      for (var j = 0, jj = clips.length; j < jj; ++j) {
        if (z !== currentZ && currentZ < clipZs[j]) {
          var clip = clips[j];
          if (intersects([currentClip[0], currentClip[3], currentClip[4], currentClip[7]], [clip[0], clip[3], clip[4], clip[7]])) {
            if (!contextSaved) {
              context.save();
              contextSaved = true;
            }
            context.beginPath();
            context.moveTo(currentClip[0], currentClip[1]);
            context.lineTo(currentClip[2], currentClip[3]);
            context.lineTo(currentClip[4], currentClip[5]);
            context.lineTo(currentClip[6], currentClip[7]);
            context.moveTo(clip[6], clip[7]);
            context.lineTo(clip[4], clip[5]);
            context.lineTo(clip[2], clip[3]);
            context.lineTo(clip[0], clip[1]);
            context.clip();
          }
        }
      }
      clips.push(currentClip);
      clipZs.push(currentZ);
      for (var t = 0, tt = executorGroups.length; t < tt; ++t) {
        var executorGroup = executorGroups[t];
        executorGroup.execute(context, 1, transform, rotation, hifi, replayTypes);
      }
      if (contextSaved) {
        context.restore();
      }
    }
    context.globalAlpha = alpha;
    return this.container;
  };
  CanvasVectorTileLayerRenderer2.prototype.renderFeature = function(feature, squaredTolerance, styles, builderGroup, opt_declutterBuilderGroup) {
    if (!styles) {
      return false;
    }
    var loading = false;
    if (Array.isArray(styles)) {
      for (var i = 0, ii = styles.length; i < ii; ++i) {
        loading = renderFeature(builderGroup, feature, styles[i], squaredTolerance, this.boundHandleStyleImageChange_, void 0, opt_declutterBuilderGroup) || loading;
      }
    } else {
      loading = renderFeature(builderGroup, feature, styles, squaredTolerance, this.boundHandleStyleImageChange_, void 0, opt_declutterBuilderGroup);
    }
    return loading;
  };
  CanvasVectorTileLayerRenderer2.prototype.tileImageNeedsRender_ = function(tile) {
    var layer = this.getLayer();
    if (layer.getRenderMode() === VectorTileRenderType_default.VECTOR) {
      return false;
    }
    var replayState = tile.getReplayState(layer);
    var revision = layer.getRevision();
    var resolution = tile.wantedResolution;
    return replayState.renderedTileResolution !== resolution || replayState.renderedTileRevision !== revision;
  };
  CanvasVectorTileLayerRenderer2.prototype.renderTileImage_ = function(tile, frameState) {
    var layer = this.getLayer();
    var replayState = tile.getReplayState(layer);
    var revision = layer.getRevision();
    var executorGroups = tile.executorGroups[getUid(layer)];
    replayState.renderedTileRevision = revision;
    var tileCoord = tile.wrappedTileCoord;
    var z = tileCoord[0];
    var source = layer.getSource();
    var pixelRatio = frameState.pixelRatio;
    var viewState = frameState.viewState;
    var projection = viewState.projection;
    var tileGrid = source.getTileGridForProjection(projection);
    var tileResolution = tileGrid.getResolution(tile.tileCoord[0]);
    var renderPixelRatio = frameState.pixelRatio / tile.wantedResolution * tileResolution;
    var resolution = tileGrid.getResolution(z);
    var context = tile.getContext(layer);
    pixelRatio = Math.round(Math.max(pixelRatio, renderPixelRatio / pixelRatio));
    var size = source.getTilePixelSize(z, pixelRatio, projection);
    context.canvas.width = size[0];
    context.canvas.height = size[1];
    var renderScale = pixelRatio / renderPixelRatio;
    if (renderScale !== 1) {
      var canvasTransform = reset(this.tmpTransform_);
      scale(canvasTransform, renderScale, renderScale);
      context.setTransform.apply(context, canvasTransform);
    }
    var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);
    var pixelScale = renderPixelRatio / resolution;
    var transform = reset(this.tmpTransform_);
    scale(transform, pixelScale, -pixelScale);
    translate(transform, -tileExtent[0], -tileExtent[3]);
    for (var i = 0, ii = executorGroups.length; i < ii; ++i) {
      var executorGroup = executorGroups[i];
      executorGroup.execute(context, renderScale, transform, 0, true, IMAGE_REPLAYS[layer.getRenderMode()]);
    }
    replayState.renderedTileResolution = tile.wantedResolution;
  };
  return CanvasVectorTileLayerRenderer2;
}(TileLayer_default);
var VectorTileLayer_default = CanvasVectorTileLayerRenderer;

// node_modules/ol/layer/VectorTile.js
var __extends2 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var VectorTileLayer = function(_super) {
  __extends2(VectorTileLayer2, _super);
  function VectorTileLayer2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    var baseOptions = assign({}, options);
    delete baseOptions.preload;
    delete baseOptions.useInterimTilesOnError;
    _this = _super.call(this, baseOptions) || this;
    _this.on;
    _this.once;
    _this.un;
    if (options.renderMode === VectorTileRenderType_default.IMAGE) {
      console.warn('renderMode: "image" is deprecated. Option ignored.');
      options.renderMode = void 0;
    }
    var renderMode = options.renderMode || VectorTileRenderType_default.HYBRID;
    assert(renderMode == VectorTileRenderType_default.HYBRID || renderMode == VectorTileRenderType_default.VECTOR, 28);
    _this.renderMode_ = renderMode;
    _this.setPreload(options.preload ? options.preload : 0);
    _this.setUseInterimTilesOnError(options.useInterimTilesOnError !== void 0 ? options.useInterimTilesOnError : true);
    _this.getBackground;
    _this.setBackground;
    return _this;
  }
  VectorTileLayer2.prototype.createRenderer = function() {
    return new VectorTileLayer_default(this);
  };
  VectorTileLayer2.prototype.getFeatures = function(pixel) {
    return _super.prototype.getFeatures.call(this, pixel);
  };
  VectorTileLayer2.prototype.getRenderMode = function() {
    return this.renderMode_;
  };
  VectorTileLayer2.prototype.getPreload = function() {
    return this.get(TileProperty_default.PRELOAD);
  };
  VectorTileLayer2.prototype.getUseInterimTilesOnError = function() {
    return this.get(TileProperty_default.USE_INTERIM_TILES_ON_ERROR);
  };
  VectorTileLayer2.prototype.setPreload = function(preload) {
    this.set(TileProperty_default.PRELOAD, preload);
  };
  VectorTileLayer2.prototype.setUseInterimTilesOnError = function(useInterimTilesOnError) {
    this.set(TileProperty_default.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
  };
  return VectorTileLayer2;
}(BaseVector_default);
var VectorTile_default = VectorTileLayer;

export {
  VectorTile_default
};
//# sourceMappingURL=chunk-IGD25YNA.js.map
