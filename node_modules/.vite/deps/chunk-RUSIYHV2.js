import {
  PointsLayer_default
} from "./chunk-XO5TAQGF.js";
import {
  BaseVector_default
} from "./chunk-Y4UODQ4X.js";
import {
  createCanvasContext2D
} from "./chunk-HPBH6HWH.js";
import {
  clamp
} from "./chunk-RDSLTYQF.js";
import {
  assign
} from "./chunk-65SWW77D.js";

// node_modules/ol/layer/Heatmap.js
var __extends = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Property = {
  BLUR: "blur",
  GRADIENT: "gradient",
  RADIUS: "radius"
};
var DEFAULT_GRADIENT = ["#00f", "#0ff", "#0f0", "#ff0", "#f00"];
var Heatmap = function(_super) {
  __extends(Heatmap2, _super);
  function Heatmap2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    var baseOptions = assign({}, options);
    delete baseOptions.gradient;
    delete baseOptions.radius;
    delete baseOptions.blur;
    delete baseOptions.weight;
    _this = _super.call(this, baseOptions) || this;
    _this.gradient_ = null;
    _this.addChangeListener(Property.GRADIENT, _this.handleGradientChanged_);
    _this.setGradient(options.gradient ? options.gradient : DEFAULT_GRADIENT);
    _this.setBlur(options.blur !== void 0 ? options.blur : 15);
    _this.setRadius(options.radius !== void 0 ? options.radius : 8);
    var weight = options.weight ? options.weight : "weight";
    if (typeof weight === "string") {
      _this.weightFunction_ = function(feature) {
        return feature.get(weight);
      };
    } else {
      _this.weightFunction_ = weight;
    }
    _this.setRenderOrder(null);
    return _this;
  }
  Heatmap2.prototype.getBlur = function() {
    return this.get(Property.BLUR);
  };
  Heatmap2.prototype.getGradient = function() {
    return this.get(Property.GRADIENT);
  };
  Heatmap2.prototype.getRadius = function() {
    return this.get(Property.RADIUS);
  };
  Heatmap2.prototype.handleGradientChanged_ = function() {
    this.gradient_ = createGradient(this.getGradient());
  };
  Heatmap2.prototype.setBlur = function(blur) {
    this.set(Property.BLUR, blur);
  };
  Heatmap2.prototype.setGradient = function(colors) {
    this.set(Property.GRADIENT, colors);
  };
  Heatmap2.prototype.setRadius = function(radius) {
    this.set(Property.RADIUS, radius);
  };
  Heatmap2.prototype.createRenderer = function() {
    return new PointsLayer_default(this, {
      className: this.getClassName(),
      attributes: [
        {
          name: "weight",
          callback: function(feature) {
            var weight = this.weightFunction_(feature);
            return weight !== void 0 ? clamp(weight, 0, 1) : 1;
          }.bind(this)
        }
      ],
      vertexShader: "\n        precision mediump float;\n        uniform mat4 u_projectionMatrix;\n        uniform mat4 u_offsetScaleMatrix;\n        uniform float u_size;\n        attribute vec2 a_position;\n        attribute float a_index;\n        attribute float a_weight;\n\n        varying vec2 v_texCoord;\n        varying float v_weight;\n\n        void main(void) {\n          mat4 offsetMatrix = u_offsetScaleMatrix;\n          float offsetX = a_index == 0.0 || a_index == 3.0 ? -u_size / 2.0 : u_size / 2.0;\n          float offsetY = a_index == 0.0 || a_index == 1.0 ? -u_size / 2.0 : u_size / 2.0;\n          vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\n          gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\n          float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\n          float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;\n          v_texCoord = vec2(u, v);\n          v_weight = a_weight;\n        }",
      fragmentShader: "\n        precision mediump float;\n        uniform float u_blurSlope;\n\n        varying vec2 v_texCoord;\n        varying float v_weight;\n\n        void main(void) {\n          vec2 texCoord = v_texCoord * 2.0 - vec2(1.0, 1.0);\n          float sqRadius = texCoord.x * texCoord.x + texCoord.y * texCoord.y;\n          float value = (1.0 - sqrt(sqRadius)) * u_blurSlope;\n          float alpha = smoothstep(0.0, 1.0, value) * v_weight;\n          gl_FragColor = vec4(alpha, alpha, alpha, alpha);\n        }",
      hitVertexShader: "\n        precision mediump float;\n        uniform mat4 u_projectionMatrix;\n        uniform mat4 u_offsetScaleMatrix;\n        uniform float u_size;\n        attribute vec2 a_position;\n        attribute float a_index;\n        attribute float a_weight;\n        attribute vec4 a_hitColor;\n\n        varying vec2 v_texCoord;\n        varying float v_weight;\n        varying vec4 v_hitColor;\n\n        void main(void) {\n          mat4 offsetMatrix = u_offsetScaleMatrix;\n          float offsetX = a_index == 0.0 || a_index == 3.0 ? -u_size / 2.0 : u_size / 2.0;\n          float offsetY = a_index == 0.0 || a_index == 1.0 ? -u_size / 2.0 : u_size / 2.0;\n          vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\n          gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\n          float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\n          float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;\n          v_texCoord = vec2(u, v);\n          v_hitColor = a_hitColor;\n          v_weight = a_weight;\n        }",
      hitFragmentShader: "\n        precision mediump float;\n        uniform float u_blurSlope;\n\n        varying vec2 v_texCoord;\n        varying float v_weight;\n        varying vec4 v_hitColor;\n\n        void main(void) {\n          vec2 texCoord = v_texCoord * 2.0 - vec2(1.0, 1.0);\n          float sqRadius = texCoord.x * texCoord.x + texCoord.y * texCoord.y;\n          float value = (1.0 - sqrt(sqRadius)) * u_blurSlope;\n          float alpha = smoothstep(0.0, 1.0, value) * v_weight;\n          if (alpha < 0.05) {\n            discard;\n          }\n\n          gl_FragColor = v_hitColor;\n        }",
      uniforms: {
        u_size: function() {
          return (this.get(Property.RADIUS) + this.get(Property.BLUR)) * 2;
        }.bind(this),
        u_blurSlope: function() {
          return this.get(Property.RADIUS) / Math.max(1, this.get(Property.BLUR));
        }.bind(this)
      },
      postProcesses: [
        {
          fragmentShader: "\n            precision mediump float;\n\n            uniform sampler2D u_image;\n            uniform sampler2D u_gradientTexture;\n            uniform float u_opacity;\n\n            varying vec2 v_texCoord;\n\n            void main() {\n              vec4 color = texture2D(u_image, v_texCoord);\n              gl_FragColor.a = color.a * u_opacity;\n              gl_FragColor.rgb = texture2D(u_gradientTexture, vec2(0.5, color.a)).rgb;\n              gl_FragColor.rgb *= gl_FragColor.a;\n            }",
          uniforms: {
            u_gradientTexture: function() {
              return this.gradient_;
            }.bind(this),
            u_opacity: function() {
              return this.getOpacity();
            }.bind(this)
          }
        }
      ]
    });
  };
  Heatmap2.prototype.renderDeclutter = function() {
  };
  return Heatmap2;
}(BaseVector_default);
function createGradient(colors) {
  var width = 1;
  var height = 256;
  var context = createCanvasContext2D(width, height);
  var gradient = context.createLinearGradient(0, 0, width, height);
  var step = 1 / (colors.length - 1);
  for (var i = 0, ii = colors.length; i < ii; ++i) {
    gradient.addColorStop(i * step, colors[i]);
  }
  context.fillStyle = gradient;
  context.fillRect(0, 0, width, height);
  return context.canvas;
}
var Heatmap_default = Heatmap;

export {
  Heatmap_default
};
//# sourceMappingURL=chunk-RUSIYHV2.js.map
