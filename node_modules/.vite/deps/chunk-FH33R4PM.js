import {
  ARRAY_BUFFER,
  AttributeType,
  Buffer_default,
  ELEMENT_ARRAY_BUFFER,
  Layer_default as Layer_default2,
  PointsLayer_default,
  STATIC_DRAW,
  create as create2,
  fromTransform
} from "./chunk-XO5TAQGF.js";
import {
  Tile_default as Tile_default2
} from "./chunk-6TRFZY4T.js";
import {
  LRUCache_default
} from "./chunk-WPDST7KJ.js";
import {
  createOrUpdate,
  getKey
} from "./chunk-N3WJGJXL.js";
import {
  ImageTile_default
} from "./chunk-G62ODYDV.js";
import {
  Tile_default
} from "./chunk-ZVEBQB7G.js";
import {
  TileRange_default
} from "./chunk-KE2T25IH.js";
import {
  IMAGE_SMOOTHING_DISABLED
} from "./chunk-LJGIG2JF.js";
import {
  TileState_default
} from "./chunk-TTYWGBB4.js";
import {
  toSize
} from "./chunk-52GDN6Z5.js";
import {
  Layer_default
} from "./chunk-TBAL5KHY.js";
import {
  asArray,
  fromString,
  isStringColor
} from "./chunk-RMQQ5XY2.js";
import {
  State_default
} from "./chunk-OIGY3JBW.js";
import {
  createCanvasContext2D
} from "./chunk-HPBH6HWH.js";
import {
  fromUserExtent
} from "./chunk-SXHM4DXD.js";
import {
  apply,
  compose,
  create
} from "./chunk-HQZSRF55.js";
import {
  log2
} from "./chunk-RDSLTYQF.js";
import {
  EventType_default,
  Target_default
} from "./chunk-POSIMZXH.js";
import {
  assign
} from "./chunk-65SWW77D.js";
import {
  containsCoordinate,
  getIntersection,
  isEmpty
} from "./chunk-4LIZYYTK.js";
import {
  numberSafeCompareFunction
} from "./chunk-6G6NVFIA.js";
import {
  getUid
} from "./chunk-2WYEPIST.js";

// node_modules/ol/webgl/PaletteTexture.js
var PaletteTexture = function() {
  function PaletteTexture2(name, data) {
    this.name = name;
    this.data = data;
    this.texture_ = null;
  }
  PaletteTexture2.prototype.getTexture = function(gl) {
    if (!this.texture_) {
      var texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.data.length / 4, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.data);
      this.texture_ = texture;
    }
    return this.texture_;
  };
  return PaletteTexture2;
}();
var PaletteTexture_default = PaletteTexture;

// node_modules/ol/DataTile.js
var __extends = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var DataTile = function(_super) {
  __extends(DataTile2, _super);
  function DataTile2(options) {
    var _this = this;
    var state = TileState_default.IDLE;
    _this = _super.call(this, options.tileCoord, state, {
      transition: options.transition,
      interpolate: options.interpolate
    }) || this;
    _this.loader_ = options.loader;
    _this.data_ = null;
    _this.error_ = null;
    return _this;
  }
  DataTile2.prototype.getData = function() {
    return this.data_;
  };
  DataTile2.prototype.getError = function() {
    return this.error_;
  };
  DataTile2.prototype.load = function() {
    this.state = TileState_default.LOADING;
    this.changed();
    var self = this;
    this.loader_().then(function(data) {
      self.data_ = data;
      self.state = TileState_default.LOADED;
      self.changed();
    }).catch(function(error) {
      self.error_ = error;
      self.state = TileState_default.ERROR;
      self.changed();
    });
  };
  return DataTile2;
}(Tile_default);
var DataTile_default = DataTile;

// node_modules/ol/webgl/TileTexture.js
var __extends2 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
function bindAndConfigure(gl, texture, interpolate) {
  var resampleFilter = interpolate ? gl.LINEAR : gl.NEAREST;
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, resampleFilter);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, resampleFilter);
}
function uploadImageTexture(gl, texture, image, interpolate) {
  bindAndConfigure(gl, texture, interpolate);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
}
function uploadDataTexture(helper, texture, data, size, bandCount, interpolate) {
  var gl = helper.getGL();
  var textureType;
  var canInterpolate;
  if (data instanceof Float32Array) {
    textureType = gl.FLOAT;
    helper.getExtension("OES_texture_float");
    var extension = helper.getExtension("OES_texture_float_linear");
    canInterpolate = extension !== null;
  } else {
    textureType = gl.UNSIGNED_BYTE;
    canInterpolate = true;
  }
  bindAndConfigure(gl, texture, interpolate && canInterpolate);
  var bytesPerRow = data.byteLength / size[1];
  var unpackAlignment = 1;
  if (bytesPerRow % 8 === 0) {
    unpackAlignment = 8;
  } else if (bytesPerRow % 4 === 0) {
    unpackAlignment = 4;
  } else if (bytesPerRow % 2 === 0) {
    unpackAlignment = 2;
  }
  var format;
  switch (bandCount) {
    case 1: {
      format = gl.LUMINANCE;
      break;
    }
    case 2: {
      format = gl.LUMINANCE_ALPHA;
      break;
    }
    case 3: {
      format = gl.RGB;
      break;
    }
    case 4: {
      format = gl.RGBA;
      break;
    }
    default: {
      throw new Error("Unsupported number of bands: ".concat(bandCount));
    }
  }
  var oldUnpackAlignment = gl.getParameter(gl.UNPACK_ALIGNMENT);
  gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);
  gl.texImage2D(gl.TEXTURE_2D, 0, format, size[0], size[1], 0, format, textureType, data);
  gl.pixelStorei(gl.UNPACK_ALIGNMENT, oldUnpackAlignment);
}
var pixelContext = null;
function createPixelContext() {
  var canvas = document.createElement("canvas");
  canvas.width = 1;
  canvas.height = 1;
  pixelContext = canvas.getContext("2d");
}
var TileTexture = function(_super) {
  __extends2(TileTexture2, _super);
  function TileTexture2(options) {
    var _this = _super.call(this) || this;
    _this.tile;
    _this.textures = [];
    _this.handleTileChange_ = _this.handleTileChange_.bind(_this);
    _this.size = toSize(options.grid.getTileSize(options.tile.tileCoord[0]));
    _this.tilePixelRatio_ = options.tilePixelRatio || 1;
    _this.gutter_ = options.gutter || 0;
    _this.bandCount = NaN;
    _this.helper_ = options.helper;
    var coords = new Buffer_default(ARRAY_BUFFER, STATIC_DRAW);
    coords.fromArray([
      0,
      1,
      1,
      1,
      1,
      0,
      0,
      0
    ]);
    _this.helper_.flushBufferData(coords);
    _this.coords = coords;
    _this.setTile(options.tile);
    return _this;
  }
  TileTexture2.prototype.setTile = function(tile) {
    if (tile !== this.tile) {
      if (this.tile) {
        this.tile.removeEventListener(EventType_default.CHANGE, this.handleTileChange_);
      }
      this.tile = tile;
      this.textures.length = 0;
      this.loaded = tile.getState() === TileState_default.LOADED;
      if (this.loaded) {
        this.uploadTile_();
      } else {
        if (tile instanceof ImageTile_default) {
          var image = tile.getImage();
          if (image instanceof Image && !image.crossOrigin) {
            image.crossOrigin = "anonymous";
          }
        }
        tile.addEventListener(EventType_default.CHANGE, this.handleTileChange_);
      }
    }
  };
  TileTexture2.prototype.uploadTile_ = function() {
    var helper = this.helper_;
    var gl = helper.getGL();
    var tile = this.tile;
    if (tile instanceof ImageTile_default || tile instanceof Tile_default2) {
      var image = tile.getImage();
      if (this.gutter_ !== 0) {
        var gutter = this.tilePixelRatio_ * this.gutter_;
        var width = Math.round(image.width - 2 * gutter);
        var height = Math.round(image.height - 2 * gutter);
        var context = createCanvasContext2D(width, height);
        if (!tile.interpolate) {
          assign(context, IMAGE_SMOOTHING_DISABLED);
        }
        context.drawImage(image, gutter, gutter, width, height, 0, 0, width, height);
        image = context.canvas;
      }
      var texture = gl.createTexture();
      this.textures.push(texture);
      this.bandCount = 4;
      uploadImageTexture(gl, texture, image, tile.interpolate);
      return;
    }
    var pixelSize = [
      this.size[0] * this.tilePixelRatio_,
      this.size[1] * this.tilePixelRatio_
    ];
    var data = tile.getData();
    var isFloat = data instanceof Float32Array;
    var pixelCount = pixelSize[0] * pixelSize[1];
    var DataType = isFloat ? Float32Array : Uint8Array;
    var bytesPerElement = DataType.BYTES_PER_ELEMENT;
    var bytesPerRow = data.byteLength / pixelSize[1];
    this.bandCount = Math.floor(bytesPerRow / bytesPerElement / pixelSize[0]);
    var textureCount = Math.ceil(this.bandCount / 4);
    if (textureCount === 1) {
      var texture = gl.createTexture();
      this.textures.push(texture);
      uploadDataTexture(helper, texture, data, pixelSize, this.bandCount, tile.interpolate);
      return;
    }
    var textureDataArrays = new Array(textureCount);
    for (var textureIndex = 0; textureIndex < textureCount; ++textureIndex) {
      var texture = gl.createTexture();
      this.textures.push(texture);
      var bandCount = textureIndex < textureCount - 1 ? 4 : this.bandCount % 4;
      textureDataArrays[textureIndex] = new DataType(pixelCount * bandCount);
    }
    var dataIndex = 0;
    var rowOffset = 0;
    var colCount = pixelSize[0] * this.bandCount;
    for (var rowIndex = 0; rowIndex < pixelSize[1]; ++rowIndex) {
      for (var colIndex = 0; colIndex < colCount; ++colIndex) {
        var dataValue = data[rowOffset + colIndex];
        var pixelIndex = Math.floor(dataIndex / this.bandCount);
        var bandIndex = colIndex % this.bandCount;
        var textureIndex = Math.floor(bandIndex / 4);
        var textureData = textureDataArrays[textureIndex];
        var bandCount = textureData.length / pixelCount;
        var textureBandIndex = bandIndex % 4;
        textureData[pixelIndex * bandCount + textureBandIndex] = dataValue;
        ++dataIndex;
      }
      rowOffset += bytesPerRow / bytesPerElement;
    }
    for (var textureIndex = 0; textureIndex < textureCount; ++textureIndex) {
      var texture = this.textures[textureIndex];
      var textureData = textureDataArrays[textureIndex];
      var bandCount = textureData.length / pixelCount;
      uploadDataTexture(helper, texture, textureData, pixelSize, bandCount, tile.interpolate);
    }
  };
  TileTexture2.prototype.handleTileChange_ = function() {
    if (this.tile.getState() === TileState_default.LOADED) {
      this.loaded = true;
      this.uploadTile_();
      this.dispatchEvent(EventType_default.CHANGE);
    }
  };
  TileTexture2.prototype.disposeInternal = function() {
    var gl = this.helper_.getGL();
    this.helper_.deleteBuffer(this.coords);
    for (var i = 0; i < this.textures.length; ++i) {
      gl.deleteTexture(this.textures[i]);
    }
    this.tile.removeEventListener(EventType_default.CHANGE, this.handleTileChange_);
  };
  TileTexture2.prototype.getPixelData = function(col, row) {
    if (!this.loaded) {
      return null;
    }
    col = Math.floor(this.tilePixelRatio_ * col);
    row = Math.floor(this.tilePixelRatio_ * row);
    if (this.tile instanceof DataTile_default) {
      var data_1 = this.tile.getData();
      var pixelsPerRow = Math.floor(this.tilePixelRatio_ * this.size[0]);
      if (data_1 instanceof DataView) {
        var bytesPerPixel = data_1.byteLength / (this.size[0] * this.size[1]);
        var offset_1 = row * pixelsPerRow * bytesPerPixel + col * bytesPerPixel;
        var buffer = data_1.buffer.slice(offset_1, offset_1 + bytesPerPixel);
        return new DataView(buffer);
      }
      var offset = row * pixelsPerRow * this.bandCount + col * this.bandCount;
      return data_1.slice(offset, offset + this.bandCount);
    }
    if (!pixelContext) {
      createPixelContext();
    }
    pixelContext.clearRect(0, 0, 1, 1);
    var data;
    var image = this.tile.getImage();
    try {
      pixelContext.drawImage(image, col, row, 1, 1, 0, 0, 1, 1);
      data = pixelContext.getImageData(0, 0, 1, 1).data;
    } catch (err) {
      return null;
    }
    return data;
  };
  return TileTexture2;
}(Target_default);
var TileTexture_default = TileTexture;

// node_modules/ol/renderer/webgl/TileLayer.js
var __extends3 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Uniforms = {
  TILE_TEXTURE_ARRAY: "u_tileTextures",
  TILE_TRANSFORM: "u_tileTransform",
  TRANSITION_ALPHA: "u_transitionAlpha",
  DEPTH: "u_depth",
  TEXTURE_PIXEL_WIDTH: "u_texturePixelWidth",
  TEXTURE_PIXEL_HEIGHT: "u_texturePixelHeight",
  TEXTURE_RESOLUTION: "u_textureResolution",
  TEXTURE_ORIGIN_X: "u_textureOriginX",
  TEXTURE_ORIGIN_Y: "u_textureOriginY",
  RENDER_EXTENT: "u_renderExtent",
  RESOLUTION: "u_resolution",
  ZOOM: "u_zoom"
};
var Attributes = {
  TEXTURE_COORD: "a_textureCoord"
};
var attributeDescriptions = [
  {
    name: Attributes.TEXTURE_COORD,
    size: 2,
    type: AttributeType.FLOAT
  }
];
var empty = {};
function depthForZ(z) {
  return 2 * (1 - 1 / (z + 1)) - 1;
}
function addTileTextureToLookup(tileTexturesByZ, tileTexture, z) {
  if (!(z in tileTexturesByZ)) {
    tileTexturesByZ[z] = [];
  }
  tileTexturesByZ[z].push(tileTexture);
}
function getRenderExtent(frameState, extent) {
  var layerState = frameState.layerStatesArray[frameState.layerIndex];
  if (layerState.extent) {
    extent = getIntersection(extent, fromUserExtent(layerState.extent, frameState.viewState.projection));
  }
  var source = layerState.layer.getRenderSource();
  if (!source.getWrapX()) {
    var gridExtent = source.getTileGridForProjection(frameState.viewState.projection).getExtent();
    if (gridExtent) {
      extent = getIntersection(extent, gridExtent);
    }
  }
  return extent;
}
function getCacheKey(source, tileCoord) {
  return "".concat(source.getKey(), ",").concat(getKey(tileCoord));
}
var WebGLTileLayerRenderer = function(_super) {
  __extends3(WebGLTileLayerRenderer2, _super);
  function WebGLTileLayerRenderer2(tileLayer, options) {
    var _this = _super.call(this, tileLayer, {
      uniforms: options.uniforms
    }) || this;
    _this.renderComplete = false;
    _this.tileTransform_ = create();
    _this.tempMat4_ = create2();
    _this.tempTileRange_ = new TileRange_default(0, 0, 0, 0);
    _this.tempTileCoord_ = createOrUpdate(0, 0, 0);
    _this.tempSize_ = [0, 0];
    _this.program_;
    _this.vertexShader_ = options.vertexShader;
    _this.fragmentShader_ = options.fragmentShader;
    _this.indices_ = new Buffer_default(ELEMENT_ARRAY_BUFFER, STATIC_DRAW);
    _this.indices_.fromArray([0, 1, 3, 1, 2, 3]);
    var cacheSize = options.cacheSize !== void 0 ? options.cacheSize : 512;
    _this.tileTextureCache_ = new LRUCache_default(cacheSize);
    _this.paletteTextures_ = options.paletteTextures || [];
    _this.frameState_ = null;
    return _this;
  }
  WebGLTileLayerRenderer2.prototype.reset = function(options) {
    _super.prototype.reset.call(this, {
      uniforms: options.uniforms
    });
    this.vertexShader_ = options.vertexShader;
    this.fragmentShader_ = options.fragmentShader;
    this.paletteTextures_ = options.paletteTextures || [];
    if (this.helper) {
      this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_);
    }
  };
  WebGLTileLayerRenderer2.prototype.afterHelperCreated = function() {
    this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_);
    this.helper.flushBufferData(this.indices_);
  };
  WebGLTileLayerRenderer2.prototype.isDrawableTile_ = function(tile) {
    var tileLayer = this.getLayer();
    var tileState = tile.getState();
    var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();
    return tileState == TileState_default.LOADED || tileState == TileState_default.EMPTY || tileState == TileState_default.ERROR && !useInterimTilesOnError;
  };
  WebGLTileLayerRenderer2.prototype.prepareFrameInternal = function(frameState) {
    var layer = this.getLayer();
    var source = layer.getRenderSource();
    if (!source) {
      return false;
    }
    if (isEmpty(getRenderExtent(frameState, frameState.extent))) {
      return false;
    }
    return source.getState() === State_default.READY;
  };
  WebGLTileLayerRenderer2.prototype.enqueueTiles = function(frameState, extent, initialZ, tileTexturesByZ) {
    var viewState = frameState.viewState;
    var tileLayer = this.getLayer();
    var tileSource = tileLayer.getRenderSource();
    var tileGrid = tileSource.getTileGridForProjection(viewState.projection);
    var tilePixelRatio = tileSource.getTilePixelRatio(frameState.pixelRatio);
    var gutter = tileSource.getGutterForProjection(viewState.projection);
    var tileSourceKey = getUid(tileSource);
    if (!(tileSourceKey in frameState.wantedTiles)) {
      frameState.wantedTiles[tileSourceKey] = {};
    }
    var wantedTiles = frameState.wantedTiles[tileSourceKey];
    var tileTextureCache = this.tileTextureCache_;
    var minZ = Math.max(initialZ - tileLayer.getPreload(), tileGrid.getMinZoom(), tileLayer.getMinZoom());
    for (var z = initialZ; z >= minZ; --z) {
      var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, this.tempTileRange_);
      var tileResolution = tileGrid.getResolution(z);
      for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
        for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
          var tileCoord = createOrUpdate(z, x, y, this.tempTileCoord_);
          var cacheKey = getCacheKey(tileSource, tileCoord);
          var tileTexture = void 0;
          var tile = void 0;
          if (tileTextureCache.containsKey(cacheKey)) {
            tileTexture = tileTextureCache.get(cacheKey);
            tile = tileTexture.tile;
          }
          if (!tileTexture || tileTexture.tile.key !== tileSource.getKey()) {
            tile = tileSource.getTile(z, x, y, frameState.pixelRatio, viewState.projection);
            if (!tileTexture) {
              tileTexture = new TileTexture_default({
                tile,
                grid: tileGrid,
                helper: this.helper,
                tilePixelRatio,
                gutter
              });
              tileTextureCache.set(cacheKey, tileTexture);
            } else {
              if (this.isDrawableTile_(tile)) {
                tileTexture.setTile(tile);
              } else {
                var interimTile = tile.getInterimTile();
                tileTexture.setTile(interimTile);
              }
            }
          }
          addTileTextureToLookup(tileTexturesByZ, tileTexture, z);
          var tileQueueKey = tile.getKey();
          wantedTiles[tileQueueKey] = true;
          if (tile.getState() === TileState_default.IDLE) {
            if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {
              frameState.tileQueue.enqueue([
                tile,
                tileSourceKey,
                tileGrid.getTileCoordCenter(tileCoord),
                tileResolution
              ]);
            }
          }
        }
      }
    }
  };
  WebGLTileLayerRenderer2.prototype.renderFrame = function(frameState) {
    this.frameState_ = frameState;
    this.renderComplete = true;
    var gl = this.helper.getGL();
    this.preRender(gl, frameState);
    var viewState = frameState.viewState;
    var tileLayer = this.getLayer();
    var tileSource = tileLayer.getRenderSource();
    var tileGrid = tileSource.getTileGridForProjection(viewState.projection);
    var extent = getRenderExtent(frameState, frameState.extent);
    var z = tileGrid.getZForResolution(viewState.resolution, tileSource.zDirection);
    var tileTexturesByZ = {};
    if (frameState.nextExtent) {
      var targetZ = tileGrid.getZForResolution(viewState.nextResolution, tileSource.zDirection);
      var nextExtent = getRenderExtent(frameState, frameState.nextExtent);
      this.enqueueTiles(frameState, nextExtent, targetZ, tileTexturesByZ);
    }
    this.enqueueTiles(frameState, extent, z, tileTexturesByZ);
    var alphaLookup = {};
    var uid = getUid(this);
    var time = frameState.time;
    var blend = false;
    var tileTextures = tileTexturesByZ[z];
    for (var i = 0, ii = tileTextures.length; i < ii; ++i) {
      var tileTexture = tileTextures[i];
      var tile = tileTexture.tile;
      var tileCoord = tile.tileCoord;
      if (tileTexture.loaded) {
        var alpha = tile.getAlpha(uid, time);
        if (alpha === 1) {
          tile.endTransition(uid);
          continue;
        }
        blend = true;
        var tileCoordKey = getKey(tileCoord);
        alphaLookup[tileCoordKey] = alpha;
      }
      this.renderComplete = false;
      var coveredByChildren = this.findAltTiles_(tileGrid, tileCoord, z + 1, tileTexturesByZ);
      if (coveredByChildren) {
        continue;
      }
      var minZoom = tileGrid.getMinZoom();
      for (var parentZ = z - 1; parentZ >= minZoom; --parentZ) {
        var coveredByParent = this.findAltTiles_(tileGrid, tileCoord, parentZ, tileTexturesByZ);
        if (coveredByParent) {
          break;
        }
      }
    }
    this.helper.useProgram(this.program_);
    this.helper.prepareDraw(frameState, !blend);
    var zs = Object.keys(tileTexturesByZ).map(Number).sort(numberSafeCompareFunction);
    var centerX = viewState.center[0];
    var centerY = viewState.center[1];
    for (var j = 0, jj = zs.length; j < jj; ++j) {
      var tileZ = zs[j];
      var tileResolution = tileGrid.getResolution(tileZ);
      var tileSize = toSize(tileGrid.getTileSize(tileZ), this.tempSize_);
      var tileOrigin = tileGrid.getOrigin(tileZ);
      var centerI = (centerX - tileOrigin[0]) / (tileSize[0] * tileResolution);
      var centerJ = (tileOrigin[1] - centerY) / (tileSize[1] * tileResolution);
      var tileScale = viewState.resolution / tileResolution;
      var depth = depthForZ(tileZ);
      var tileTextures_1 = tileTexturesByZ[tileZ];
      for (var i = 0, ii = tileTextures_1.length; i < ii; ++i) {
        var tileTexture = tileTextures_1[i];
        if (!tileTexture.loaded) {
          continue;
        }
        var tile = tileTexture.tile;
        var tileCoord = tile.tileCoord;
        var tileCoordKey = getKey(tileCoord);
        var tileCenterI = tileCoord[1];
        var tileCenterJ = tileCoord[2];
        compose(this.tileTransform_, 0, 0, 2 / (frameState.size[0] * tileScale / tileSize[0]), -2 / (frameState.size[1] * tileScale / tileSize[1]), viewState.rotation, -(centerI - tileCenterI), -(centerJ - tileCenterJ));
        this.helper.setUniformMatrixValue(Uniforms.TILE_TRANSFORM, fromTransform(this.tempMat4_, this.tileTransform_));
        this.helper.bindBuffer(tileTexture.coords);
        this.helper.bindBuffer(this.indices_);
        this.helper.enableAttributes(attributeDescriptions);
        var textureSlot = 0;
        while (textureSlot < tileTexture.textures.length) {
          var textureProperty = "TEXTURE" + textureSlot;
          var uniformName = "".concat(Uniforms.TILE_TEXTURE_ARRAY, "[").concat(textureSlot, "]");
          gl.activeTexture(gl[textureProperty]);
          gl.bindTexture(gl.TEXTURE_2D, tileTexture.textures[textureSlot]);
          gl.uniform1i(this.helper.getUniformLocation(uniformName), textureSlot);
          ++textureSlot;
        }
        for (var paletteIndex = 0; paletteIndex < this.paletteTextures_.length; ++paletteIndex) {
          var paletteTexture = this.paletteTextures_[paletteIndex];
          gl.activeTexture(gl["TEXTURE" + textureSlot]);
          var texture = paletteTexture.getTexture(gl);
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.uniform1i(this.helper.getUniformLocation(paletteTexture.name), textureSlot);
          ++textureSlot;
        }
        var alpha = tileCoordKey in alphaLookup ? alphaLookup[tileCoordKey] : 1;
        if (alpha < 1) {
          frameState.animate = true;
        }
        this.helper.setUniformFloatValue(Uniforms.TRANSITION_ALPHA, alpha);
        this.helper.setUniformFloatValue(Uniforms.DEPTH, depth);
        this.helper.setUniformFloatValue(Uniforms.TEXTURE_PIXEL_WIDTH, tileSize[0]);
        this.helper.setUniformFloatValue(Uniforms.TEXTURE_PIXEL_HEIGHT, tileSize[1]);
        this.helper.setUniformFloatValue(Uniforms.TEXTURE_RESOLUTION, tileResolution);
        this.helper.setUniformFloatValue(Uniforms.TEXTURE_ORIGIN_X, tileOrigin[0] + tileCenterI * tileSize[0] * tileResolution);
        this.helper.setUniformFloatValue(Uniforms.TEXTURE_ORIGIN_Y, tileOrigin[1] - tileCenterJ * tileSize[1] * tileResolution);
        this.helper.setUniformFloatVec4(Uniforms.RENDER_EXTENT, extent);
        this.helper.setUniformFloatValue(Uniforms.RESOLUTION, viewState.resolution);
        this.helper.setUniformFloatValue(Uniforms.ZOOM, viewState.zoom);
        this.helper.drawElements(0, this.indices_.getSize());
      }
    }
    this.helper.finalizeDraw(frameState, this.dispatchPreComposeEvent, this.dispatchPostComposeEvent);
    var canvas = this.helper.getCanvas();
    var tileTextureCache = this.tileTextureCache_;
    while (tileTextureCache.canExpireCache()) {
      var tileTexture = tileTextureCache.pop();
      tileTexture.dispose();
    }
    var postRenderFunction = function(map, frameState2) {
      tileSource.expireCache(frameState2.viewState.projection, empty);
    };
    frameState.postRenderFunctions.push(postRenderFunction);
    this.postRender(gl, frameState);
    return canvas;
  };
  WebGLTileLayerRenderer2.prototype.getData = function(pixel) {
    var gl = this.helper.getGL();
    if (!gl) {
      return null;
    }
    var frameState = this.frameState_;
    if (!frameState) {
      return null;
    }
    var layer = this.getLayer();
    var coordinate = apply(frameState.pixelToCoordinateTransform, pixel.slice());
    var viewState = frameState.viewState;
    var layerExtent = layer.getExtent();
    if (layerExtent) {
      if (!containsCoordinate(fromUserExtent(layerExtent, viewState.projection), coordinate)) {
        return null;
      }
    }
    var source = layer.getRenderSource();
    var tileGrid = source.getTileGridForProjection(viewState.projection);
    if (!source.getWrapX()) {
      var gridExtent = tileGrid.getExtent();
      if (gridExtent) {
        if (!containsCoordinate(gridExtent, coordinate)) {
          return null;
        }
      }
    }
    var tileTextureCache = this.tileTextureCache_;
    for (var z = tileGrid.getZForResolution(viewState.resolution); z >= tileGrid.getMinZoom(); --z) {
      var tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);
      var cacheKey = getCacheKey(source, tileCoord);
      if (!tileTextureCache.containsKey(cacheKey)) {
        continue;
      }
      var tileTexture = tileTextureCache.get(cacheKey);
      if (!tileTexture.loaded) {
        continue;
      }
      var tileOrigin = tileGrid.getOrigin(z);
      var tileSize = toSize(tileGrid.getTileSize(z));
      var tileResolution = tileGrid.getResolution(z);
      var col = (coordinate[0] - tileOrigin[0]) / tileResolution - tileCoord[1] * tileSize[0];
      var row = (tileOrigin[1] - coordinate[1]) / tileResolution - tileCoord[2] * tileSize[1];
      return tileTexture.getPixelData(col, row);
    }
    return null;
  };
  WebGLTileLayerRenderer2.prototype.findAltTiles_ = function(tileGrid, tileCoord, altZ, tileTexturesByZ) {
    var tileRange = tileGrid.getTileRangeForTileCoordAndZ(tileCoord, altZ, this.tempTileRange_);
    if (!tileRange) {
      return false;
    }
    var covered = true;
    var tileTextureCache = this.tileTextureCache_;
    var source = this.getLayer().getRenderSource();
    for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
      for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
        var cacheKey = getCacheKey(source, [altZ, x, y]);
        var loaded = false;
        if (tileTextureCache.containsKey(cacheKey)) {
          var tileTexture = tileTextureCache.get(cacheKey);
          if (tileTexture.loaded) {
            addTileTextureToLookup(tileTexturesByZ, tileTexture, altZ);
            loaded = true;
          }
        }
        if (!loaded) {
          covered = false;
        }
      }
    }
    return covered;
  };
  WebGLTileLayerRenderer2.prototype.removeHelper = function() {
    if (this.helper) {
      var tileTextureCache = this.tileTextureCache_;
      tileTextureCache.forEach(function(tileTexture) {
        return tileTexture.dispose();
      });
      tileTextureCache.clear();
    }
    _super.prototype.removeHelper.call(this);
  };
  WebGLTileLayerRenderer2.prototype.disposeInternal = function() {
    var helper = this.helper;
    if (helper) {
      var gl = helper.getGL();
      gl.deleteProgram(this.program_);
      delete this.program_;
      helper.deleteBuffer(this.indices_);
    }
    _super.prototype.disposeInternal.call(this);
    delete this.indices_;
    delete this.tileTextureCache_;
    delete this.frameState_;
  };
  return WebGLTileLayerRenderer2;
}(Layer_default2);
var TileLayer_default = WebGLTileLayerRenderer;

// node_modules/ol/style/expressions.js
var ValueTypes = {
  NUMBER: 1,
  STRING: 2,
  COLOR: 4,
  BOOLEAN: 8,
  NUMBER_ARRAY: 16,
  ANY: 31,
  NONE: 0
};
var Operators = {};
function getValueType(value) {
  if (typeof value === "number") {
    return ValueTypes.NUMBER;
  }
  if (typeof value === "boolean") {
    return ValueTypes.BOOLEAN;
  }
  if (typeof value === "string") {
    if (isStringColor(value)) {
      return ValueTypes.COLOR | ValueTypes.STRING;
    }
    return ValueTypes.STRING;
  }
  if (!Array.isArray(value)) {
    throw new Error("Unhandled value type: ".concat(JSON.stringify(value)));
  }
  var valueArr = value;
  var onlyNumbers = valueArr.every(function(v) {
    return typeof v === "number";
  });
  if (onlyNumbers) {
    if (valueArr.length === 3 || valueArr.length === 4) {
      return ValueTypes.COLOR | ValueTypes.NUMBER_ARRAY;
    }
    return ValueTypes.NUMBER_ARRAY;
  }
  if (typeof valueArr[0] !== "string") {
    throw new Error("Expected an expression operator but received: ".concat(JSON.stringify(valueArr)));
  }
  var operator = Operators[valueArr[0]];
  if (operator === void 0) {
    throw new Error("Unrecognized expression operator: ".concat(JSON.stringify(valueArr)));
  }
  return operator.getReturnType(valueArr.slice(1));
}
function isTypeUnique(valueType) {
  return log2(valueType) % 1 === 0;
}
function numberToGlsl(v) {
  var s = v.toString();
  return s.indexOf(".") === -1 ? s + ".0" : s;
}
function arrayToGlsl(array) {
  if (array.length < 2 || array.length > 4) {
    throw new Error("`formatArray` can only output `vec2`, `vec3` or `vec4` arrays.");
  }
  return "vec".concat(array.length, "(").concat(array.map(numberToGlsl).join(", "), ")");
}
function colorToGlsl(color) {
  var array = asArray(color).slice();
  if (array.length < 4) {
    array.push(1);
  }
  return arrayToGlsl(array.map(function(c, i) {
    return i < 3 ? c / 255 : c;
  }));
}
function getStringNumberEquivalent(context, string) {
  if (context.stringLiteralsMap[string] === void 0) {
    context.stringLiteralsMap[string] = Object.keys(context.stringLiteralsMap).length;
  }
  return context.stringLiteralsMap[string];
}
function stringToGlsl(context, string) {
  return numberToGlsl(getStringNumberEquivalent(context, string));
}
function expressionToGlsl(context, value, typeHint) {
  if (Array.isArray(value) && typeof value[0] === "string") {
    var operator = Operators[value[0]];
    if (operator === void 0) {
      throw new Error("Unrecognized expression operator: ".concat(JSON.stringify(value)));
    }
    return operator.toGlsl(context, value.slice(1), typeHint);
  }
  var valueType = getValueType(value);
  if ((valueType & ValueTypes.NUMBER) > 0) {
    return numberToGlsl(value);
  }
  if ((valueType & ValueTypes.BOOLEAN) > 0) {
    return value.toString();
  }
  if ((valueType & ValueTypes.STRING) > 0 && (typeHint === void 0 || typeHint == ValueTypes.STRING)) {
    return stringToGlsl(context, value.toString());
  }
  if ((valueType & ValueTypes.COLOR) > 0 && (typeHint === void 0 || typeHint == ValueTypes.COLOR)) {
    return colorToGlsl(value);
  }
  if ((valueType & ValueTypes.NUMBER_ARRAY) > 0) {
    return arrayToGlsl(value);
  }
  throw new Error("Unexpected expression ".concat(value, " (expected type ").concat(typeHint, ")"));
}
function assertNumber(value) {
  if (!(getValueType(value) & ValueTypes.NUMBER)) {
    throw new Error("A numeric value was expected, got ".concat(JSON.stringify(value), " instead"));
  }
}
function assertNumbers(values) {
  for (var i = 0; i < values.length; i++) {
    assertNumber(values[i]);
  }
}
function assertString(value) {
  if (!(getValueType(value) & ValueTypes.STRING)) {
    throw new Error("A string value was expected, got ".concat(JSON.stringify(value), " instead"));
  }
}
function assertBoolean(value) {
  if (!(getValueType(value) & ValueTypes.BOOLEAN)) {
    throw new Error("A boolean value was expected, got ".concat(JSON.stringify(value), " instead"));
  }
}
function assertArgsCount(args, count) {
  if (args.length !== count) {
    throw new Error("Exactly ".concat(count, " arguments were expected, got ").concat(args.length, " instead"));
  }
}
function assertArgsMinCount(args, count) {
  if (args.length < count) {
    throw new Error("At least ".concat(count, " arguments were expected, got ").concat(args.length, " instead"));
  }
}
function assertArgsMaxCount(args, count) {
  if (args.length > count) {
    throw new Error("At most ".concat(count, " arguments were expected, got ").concat(args.length, " instead"));
  }
}
function assertArgsEven(args) {
  if (args.length % 2 !== 0) {
    throw new Error("An even amount of arguments was expected, got ".concat(args, " instead"));
  }
}
function assertArgsOdd(args) {
  if (args.length % 2 === 0) {
    throw new Error("An odd amount of arguments was expected, got ".concat(args, " instead"));
  }
}
function assertUniqueInferredType(args, types) {
  if (!isTypeUnique(types)) {
    throw new Error("Could not infer only one type from the following expression: ".concat(JSON.stringify(args)));
  }
}
Operators["get"] = {
  getReturnType: function(args) {
    return ValueTypes.ANY;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 1);
    assertString(args[0]);
    var value = args[0].toString();
    if (context.attributes.indexOf(value) === -1) {
      context.attributes.push(value);
    }
    var prefix = context.inFragmentShader ? "v_" : "a_";
    return prefix + value;
  }
};
function uniformNameForVariable(variableName) {
  return "u_var_" + variableName;
}
Operators["var"] = {
  getReturnType: function(args) {
    return ValueTypes.ANY;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 1);
    assertString(args[0]);
    var value = args[0].toString();
    if (context.variables.indexOf(value) === -1) {
      context.variables.push(value);
    }
    return uniformNameForVariable(value);
  }
};
var PALETTE_TEXTURE_ARRAY = "u_paletteTextures";
Operators["palette"] = {
  getReturnType: function(args) {
    return ValueTypes.COLOR;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 2);
    assertNumber(args[0]);
    var index = expressionToGlsl(context, args[0]);
    var colors = args[1];
    if (!Array.isArray(colors)) {
      throw new Error("The second argument of palette must be an array");
    }
    var numColors = colors.length;
    var palette = new Uint8Array(numColors * 4);
    for (var i = 0; i < numColors; i++) {
      var candidate = colors[i];
      var color = void 0;
      if (typeof candidate === "string") {
        color = fromString(candidate);
      } else {
        if (!Array.isArray(candidate)) {
          throw new Error("The second argument of palette must be an array of strings or colors");
        }
        var length_1 = candidate.length;
        if (length_1 === 4) {
          color = candidate;
        } else {
          if (length_1 !== 3) {
            throw new Error("Expected palette color to have 3 or 4 values, got ".concat(length_1));
          }
          color = [candidate[0], candidate[1], candidate[2], 1];
        }
      }
      var offset = i * 4;
      palette[offset] = color[0];
      palette[offset + 1] = color[1];
      palette[offset + 2] = color[2];
      palette[offset + 3] = color[3] * 255;
    }
    if (!context.paletteTextures) {
      context.paletteTextures = [];
    }
    var paletteName = "".concat(PALETTE_TEXTURE_ARRAY, "[").concat(context.paletteTextures.length, "]");
    var paletteTexture = new PaletteTexture_default(paletteName, palette);
    context.paletteTextures.push(paletteTexture);
    return "texture2D(".concat(paletteName, ", vec2((").concat(index, " + 0.5) / ").concat(numColors, ".0, 0.5))");
  }
};
var GET_BAND_VALUE_FUNC = "getBandValue";
Operators["band"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsMinCount(args, 1);
    assertArgsMaxCount(args, 3);
    var band = args[0];
    if (!(GET_BAND_VALUE_FUNC in context.functions)) {
      var ifBlocks = "";
      var bandCount = context.bandCount || 1;
      for (var i = 0; i < bandCount; i++) {
        var colorIndex = Math.floor(i / 4);
        var bandIndex = i % 4;
        if (bandIndex === bandCount - 1 && bandIndex === 1) {
          bandIndex = 3;
        }
        var textureName = "".concat(Uniforms.TILE_TEXTURE_ARRAY, "[").concat(colorIndex, "]");
        ifBlocks += "\n          if (band == ".concat(i + 1, ".0) {\n            return texture2D(").concat(textureName, ", v_textureCoord + vec2(dx, dy))[").concat(bandIndex, "];\n          }\n        ");
      }
      context.functions[GET_BAND_VALUE_FUNC] = "\n        float getBandValue(float band, float xOffset, float yOffset) {\n          float dx = xOffset / ".concat(Uniforms.TEXTURE_PIXEL_WIDTH, ";\n          float dy = yOffset / ").concat(Uniforms.TEXTURE_PIXEL_HEIGHT, ";\n          ").concat(ifBlocks, "\n        }\n      ");
    }
    var bandExpression = expressionToGlsl(context, band);
    var xOffsetExpression = expressionToGlsl(context, args[1] || 0);
    var yOffsetExpression = expressionToGlsl(context, args[2] || 0);
    return "".concat(GET_BAND_VALUE_FUNC, "(").concat(bandExpression, ", ").concat(xOffsetExpression, ", ").concat(yOffsetExpression, ")");
  }
};
Operators["time"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 0);
    return "u_time";
  }
};
Operators["zoom"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 0);
    return "u_zoom";
  }
};
Operators["resolution"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 0);
    return "u_resolution";
  }
};
Operators["*"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return "(".concat(expressionToGlsl(context, args[0]), " * ").concat(expressionToGlsl(context, args[1]), ")");
  }
};
Operators["/"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return "(".concat(expressionToGlsl(context, args[0]), " / ").concat(expressionToGlsl(context, args[1]), ")");
  }
};
Operators["+"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return "(".concat(expressionToGlsl(context, args[0]), " + ").concat(expressionToGlsl(context, args[1]), ")");
  }
};
Operators["-"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return "(".concat(expressionToGlsl(context, args[0]), " - ").concat(expressionToGlsl(context, args[1]), ")");
  }
};
Operators["clamp"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 3);
    assertNumbers(args);
    var min = expressionToGlsl(context, args[1]);
    var max = expressionToGlsl(context, args[2]);
    return "clamp(".concat(expressionToGlsl(context, args[0]), ", ").concat(min, ", ").concat(max, ")");
  }
};
Operators["%"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return "mod(".concat(expressionToGlsl(context, args[0]), ", ").concat(expressionToGlsl(context, args[1]), ")");
  }
};
Operators["^"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return "pow(".concat(expressionToGlsl(context, args[0]), ", ").concat(expressionToGlsl(context, args[1]), ")");
  }
};
Operators["abs"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 1);
    assertNumbers(args);
    return "abs(".concat(expressionToGlsl(context, args[0]), ")");
  }
};
Operators["floor"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 1);
    assertNumbers(args);
    return "floor(".concat(expressionToGlsl(context, args[0]), ")");
  }
};
Operators["round"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 1);
    assertNumbers(args);
    return "floor(".concat(expressionToGlsl(context, args[0]), " + 0.5)");
  }
};
Operators["ceil"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 1);
    assertNumbers(args);
    return "ceil(".concat(expressionToGlsl(context, args[0]), ")");
  }
};
Operators["sin"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 1);
    assertNumbers(args);
    return "sin(".concat(expressionToGlsl(context, args[0]), ")");
  }
};
Operators["cos"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 1);
    assertNumbers(args);
    return "cos(".concat(expressionToGlsl(context, args[0]), ")");
  }
};
Operators["atan"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER;
  },
  toGlsl: function(context, args) {
    assertArgsMinCount(args, 1);
    assertArgsMaxCount(args, 2);
    assertNumbers(args);
    return args.length === 2 ? "atan(".concat(expressionToGlsl(context, args[0]), ", ").concat(expressionToGlsl(context, args[1]), ")") : "atan(".concat(expressionToGlsl(context, args[0]), ")");
  }
};
Operators[">"] = {
  getReturnType: function(args) {
    return ValueTypes.BOOLEAN;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return "(".concat(expressionToGlsl(context, args[0]), " > ").concat(expressionToGlsl(context, args[1]), ")");
  }
};
Operators[">="] = {
  getReturnType: function(args) {
    return ValueTypes.BOOLEAN;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return "(".concat(expressionToGlsl(context, args[0]), " >= ").concat(expressionToGlsl(context, args[1]), ")");
  }
};
Operators["<"] = {
  getReturnType: function(args) {
    return ValueTypes.BOOLEAN;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return "(".concat(expressionToGlsl(context, args[0]), " < ").concat(expressionToGlsl(context, args[1]), ")");
  }
};
Operators["<="] = {
  getReturnType: function(args) {
    return ValueTypes.BOOLEAN;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 2);
    assertNumbers(args);
    return "(".concat(expressionToGlsl(context, args[0]), " <= ").concat(expressionToGlsl(context, args[1]), ")");
  }
};
function getEqualOperator(operator) {
  return {
    getReturnType: function(args) {
      return ValueTypes.BOOLEAN;
    },
    toGlsl: function(context, args) {
      assertArgsCount(args, 2);
      var type = ValueTypes.ANY;
      for (var i = 0; i < args.length; i++) {
        type &= getValueType(args[i]);
      }
      if (type === ValueTypes.NONE) {
        throw new Error("All arguments should be of compatible type, got ".concat(JSON.stringify(args), " instead"));
      }
      type &= ~ValueTypes.COLOR;
      return "(".concat(expressionToGlsl(context, args[0], type), " ").concat(operator, " ").concat(expressionToGlsl(context, args[1], type), ")");
    }
  };
}
Operators["=="] = getEqualOperator("==");
Operators["!="] = getEqualOperator("!=");
Operators["!"] = {
  getReturnType: function(args) {
    return ValueTypes.BOOLEAN;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 1);
    assertBoolean(args[0]);
    return "(!".concat(expressionToGlsl(context, args[0]), ")");
  }
};
function getDecisionOperator(operator) {
  return {
    getReturnType: function(args) {
      return ValueTypes.BOOLEAN;
    },
    toGlsl: function(context, args) {
      assertArgsMinCount(args, 2);
      for (var i = 0; i < args.length; i++) {
        assertBoolean(args[i]);
      }
      var result = "";
      result = args.map(function(arg) {
        return expressionToGlsl(context, arg);
      }).join(" ".concat(operator, " "));
      result = "(".concat(result, ")");
      return result;
    }
  };
}
Operators["all"] = getDecisionOperator("&&");
Operators["any"] = getDecisionOperator("||");
Operators["between"] = {
  getReturnType: function(args) {
    return ValueTypes.BOOLEAN;
  },
  toGlsl: function(context, args) {
    assertArgsCount(args, 3);
    assertNumbers(args);
    var min = expressionToGlsl(context, args[1]);
    var max = expressionToGlsl(context, args[2]);
    var value = expressionToGlsl(context, args[0]);
    return "(".concat(value, " >= ").concat(min, " && ").concat(value, " <= ").concat(max, ")");
  }
};
Operators["array"] = {
  getReturnType: function(args) {
    return ValueTypes.NUMBER_ARRAY;
  },
  toGlsl: function(context, args) {
    assertArgsMinCount(args, 2);
    assertArgsMaxCount(args, 4);
    assertNumbers(args);
    var parsedArgs = args.map(function(val) {
      return expressionToGlsl(context, val, ValueTypes.NUMBER);
    });
    return "vec".concat(args.length, "(").concat(parsedArgs.join(", "), ")");
  }
};
Operators["color"] = {
  getReturnType: function(args) {
    return ValueTypes.COLOR;
  },
  toGlsl: function(context, args) {
    assertArgsMinCount(args, 3);
    assertArgsMaxCount(args, 4);
    assertNumbers(args);
    var array = args;
    if (args.length === 3) {
      array.push(1);
    }
    var parsedArgs = args.map(function(val, i) {
      return expressionToGlsl(context, val, ValueTypes.NUMBER) + (i < 3 ? " / 255.0" : "");
    });
    return "vec".concat(args.length, "(").concat(parsedArgs.join(", "), ")");
  }
};
Operators["interpolate"] = {
  getReturnType: function(args) {
    var type = ValueTypes.COLOR | ValueTypes.NUMBER;
    for (var i = 3; i < args.length; i += 2) {
      type = type & getValueType(args[i]);
    }
    return type;
  },
  toGlsl: function(context, args, opt_typeHint) {
    assertArgsEven(args);
    assertArgsMinCount(args, 6);
    var type = args[0];
    var interpolation;
    switch (type[0]) {
      case "linear":
        interpolation = 1;
        break;
      case "exponential":
        interpolation = type[1];
        break;
      default:
        interpolation = null;
    }
    if (!interpolation) {
      throw new Error('Invalid interpolation type for "interpolate" operator, received: '.concat(JSON.stringify(type)));
    }
    var typeHint = opt_typeHint !== void 0 ? opt_typeHint : ValueTypes.ANY;
    var outputType = Operators["interpolate"].getReturnType(args) & typeHint;
    assertUniqueInferredType(args, outputType);
    var input = expressionToGlsl(context, args[1]);
    var exponent = numberToGlsl(interpolation);
    var result = "";
    for (var i = 2; i < args.length - 2; i += 2) {
      var stop1 = expressionToGlsl(context, args[i]);
      var output1 = result || expressionToGlsl(context, args[i + 1], outputType);
      var stop2 = expressionToGlsl(context, args[i + 2]);
      var output2 = expressionToGlsl(context, args[i + 3], outputType);
      result = "mix(".concat(output1, ", ").concat(output2, ", pow(clamp((").concat(input, " - ").concat(stop1, ") / (").concat(stop2, " - ").concat(stop1, "), 0.0, 1.0), ").concat(exponent, "))");
    }
    return result;
  }
};
Operators["match"] = {
  getReturnType: function(args) {
    var type = ValueTypes.ANY;
    for (var i = 2; i < args.length; i += 2) {
      type = type & getValueType(args[i]);
    }
    type = type & getValueType(args[args.length - 1]);
    return type;
  },
  toGlsl: function(context, args, opt_typeHint) {
    assertArgsEven(args);
    assertArgsMinCount(args, 4);
    var typeHint = opt_typeHint !== void 0 ? opt_typeHint : ValueTypes.ANY;
    var outputType = Operators["match"].getReturnType(args) & typeHint;
    assertUniqueInferredType(args, outputType);
    var input = expressionToGlsl(context, args[0]);
    var fallback = expressionToGlsl(context, args[args.length - 1], outputType);
    var result = null;
    for (var i = args.length - 3; i >= 1; i -= 2) {
      var match = expressionToGlsl(context, args[i]);
      var output = expressionToGlsl(context, args[i + 1], outputType);
      result = "(".concat(input, " == ").concat(match, " ? ").concat(output, " : ").concat(result || fallback, ")");
    }
    return result;
  }
};
Operators["case"] = {
  getReturnType: function(args) {
    var type = ValueTypes.ANY;
    for (var i = 1; i < args.length; i += 2) {
      type = type & getValueType(args[i]);
    }
    type = type & getValueType(args[args.length - 1]);
    return type;
  },
  toGlsl: function(context, args, opt_typeHint) {
    assertArgsOdd(args);
    assertArgsMinCount(args, 3);
    var typeHint = opt_typeHint !== void 0 ? opt_typeHint : ValueTypes.ANY;
    var outputType = Operators["case"].getReturnType(args) & typeHint;
    assertUniqueInferredType(args, outputType);
    for (var i = 0; i < args.length - 1; i += 2) {
      assertBoolean(args[i]);
    }
    var fallback = expressionToGlsl(context, args[args.length - 1], outputType);
    var result = null;
    for (var i = args.length - 3; i >= 0; i -= 2) {
      var condition = expressionToGlsl(context, args[i]);
      var output = expressionToGlsl(context, args[i + 1], outputType);
      result = "(".concat(condition, " ? ").concat(output, " : ").concat(result || fallback, ")");
    }
    return result;
  }
};

// node_modules/ol/webgl/ShaderBuilder.js
var ShaderBuilder = function() {
  function ShaderBuilder2() {
    this.uniforms = [];
    this.attributes = [];
    this.varyings = [];
    this.sizeExpression = "vec2(1.0)";
    this.rotationExpression = "0.0";
    this.offsetExpression = "vec2(0.0)";
    this.colorExpression = "vec4(1.0)";
    this.texCoordExpression = "vec4(0.0, 0.0, 1.0, 1.0)";
    this.discardExpression = "false";
    this.rotateWithView = false;
  }
  ShaderBuilder2.prototype.addUniform = function(name) {
    this.uniforms.push(name);
    return this;
  };
  ShaderBuilder2.prototype.addAttribute = function(name) {
    this.attributes.push(name);
    return this;
  };
  ShaderBuilder2.prototype.addVarying = function(name, type, expression) {
    this.varyings.push({
      name,
      type,
      expression
    });
    return this;
  };
  ShaderBuilder2.prototype.setSizeExpression = function(expression) {
    this.sizeExpression = expression;
    return this;
  };
  ShaderBuilder2.prototype.setRotationExpression = function(expression) {
    this.rotationExpression = expression;
    return this;
  };
  ShaderBuilder2.prototype.setSymbolOffsetExpression = function(expression) {
    this.offsetExpression = expression;
    return this;
  };
  ShaderBuilder2.prototype.setColorExpression = function(expression) {
    this.colorExpression = expression;
    return this;
  };
  ShaderBuilder2.prototype.setTextureCoordinateExpression = function(expression) {
    this.texCoordExpression = expression;
    return this;
  };
  ShaderBuilder2.prototype.setFragmentDiscardExpression = function(expression) {
    this.discardExpression = expression;
    return this;
  };
  ShaderBuilder2.prototype.setSymbolRotateWithView = function(rotateWithView) {
    this.rotateWithView = rotateWithView;
    return this;
  };
  ShaderBuilder2.prototype.getSizeExpression = function() {
    return this.sizeExpression;
  };
  ShaderBuilder2.prototype.getOffsetExpression = function() {
    return this.offsetExpression;
  };
  ShaderBuilder2.prototype.getColorExpression = function() {
    return this.colorExpression;
  };
  ShaderBuilder2.prototype.getTextureCoordinateExpression = function() {
    return this.texCoordExpression;
  };
  ShaderBuilder2.prototype.getFragmentDiscardExpression = function() {
    return this.discardExpression;
  };
  ShaderBuilder2.prototype.getSymbolVertexShader = function(forHitDetection) {
    var offsetMatrix = this.rotateWithView ? "u_offsetScaleMatrix * u_offsetRotateMatrix" : "u_offsetScaleMatrix";
    var attributes = this.attributes;
    var varyings = this.varyings;
    if (forHitDetection) {
      attributes = attributes.concat("vec4 a_hitColor");
      varyings = varyings.concat({
        name: "v_hitColor",
        type: "vec4",
        expression: "a_hitColor"
      });
    }
    return "precision mediump float;\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_offsetScaleMatrix;\nuniform mat4 u_offsetRotateMatrix;\nuniform float u_time;\nuniform float u_zoom;\nuniform float u_resolution;\n".concat(this.uniforms.map(function(uniform) {
      return "uniform " + uniform + ";";
    }).join("\n"), "\nattribute vec2 a_position;\nattribute float a_index;\n").concat(attributes.map(function(attribute) {
      return "attribute " + attribute + ";";
    }).join("\n"), "\nvarying vec2 v_texCoord;\nvarying vec2 v_quadCoord;\n").concat(varyings.map(function(varying) {
      return "varying " + varying.type + " " + varying.name + ";";
    }).join("\n"), "\nvoid main(void) {\n  mat4 offsetMatrix = ").concat(offsetMatrix, ";\n  vec2 halfSize = ").concat(this.sizeExpression, " * 0.5;\n  vec2 offset = ").concat(this.offsetExpression, ";\n  float angle = ").concat(this.rotationExpression, ";\n  float offsetX;\n  float offsetY;\n  if (a_index == 0.0) {\n    offsetX = (offset.x - halfSize.x) * cos(angle) + (offset.y - halfSize.y) * sin(angle);\n    offsetY = (offset.y - halfSize.y) * cos(angle) - (offset.x - halfSize.x) * sin(angle);\n  } else if (a_index == 1.0) {\n    offsetX = (offset.x + halfSize.x) * cos(angle) + (offset.y - halfSize.y) * sin(angle);\n    offsetY = (offset.y - halfSize.y) * cos(angle) - (offset.x + halfSize.x) * sin(angle);\n  } else if (a_index == 2.0) {\n    offsetX = (offset.x + halfSize.x) * cos(angle) + (offset.y + halfSize.y) * sin(angle);\n    offsetY = (offset.y + halfSize.y) * cos(angle) - (offset.x + halfSize.x) * sin(angle);\n  } else {\n    offsetX = (offset.x - halfSize.x) * cos(angle) + (offset.y + halfSize.y) * sin(angle);\n    offsetY = (offset.y + halfSize.y) * cos(angle) - (offset.x - halfSize.x) * sin(angle);\n  }\n  vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\n  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\n  vec4 texCoord = ").concat(this.texCoordExpression, ";\n  float u = a_index == 0.0 || a_index == 3.0 ? texCoord.s : texCoord.p;\n  float v = a_index == 2.0 || a_index == 3.0 ? texCoord.t : texCoord.q;\n  v_texCoord = vec2(u, v);\n  u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\n  v = a_index == 2.0 || a_index == 3.0 ? 0.0 : 1.0;\n  v_quadCoord = vec2(u, v);\n").concat(varyings.map(function(varying) {
      return "  " + varying.name + " = " + varying.expression + ";";
    }).join("\n"), "\n}");
  };
  ShaderBuilder2.prototype.getSymbolFragmentShader = function(forHitDetection) {
    var hitDetectionBypass = forHitDetection ? "  if (gl_FragColor.a < 0.1) { discard; } gl_FragColor = v_hitColor;" : "";
    var varyings = this.varyings;
    if (forHitDetection) {
      varyings = varyings.concat({
        name: "v_hitColor",
        type: "vec4",
        expression: "a_hitColor"
      });
    }
    return "precision mediump float;\nuniform float u_time;\nuniform float u_zoom;\nuniform float u_resolution;\n".concat(this.uniforms.map(function(uniform) {
      return "uniform " + uniform + ";";
    }).join("\n"), "\nvarying vec2 v_texCoord;\nvarying vec2 v_quadCoord;\n").concat(varyings.map(function(varying) {
      return "varying " + varying.type + " " + varying.name + ";";
    }).join("\n"), "\nvoid main(void) {\n  if (").concat(this.discardExpression, ") { discard; }\n  gl_FragColor = ").concat(this.colorExpression, ";\n  gl_FragColor.rgb *= gl_FragColor.a;\n").concat(hitDetectionBypass, "\n}");
  };
  return ShaderBuilder2;
}();
function parseLiteralStyle(style) {
  var symbStyle = style.symbol;
  var size = symbStyle.size !== void 0 ? symbStyle.size : 1;
  var color = symbStyle.color || "white";
  var texCoord = symbStyle.textureCoord || [0, 0, 1, 1];
  var offset = symbStyle.offset || [0, 0];
  var opacity = symbStyle.opacity !== void 0 ? symbStyle.opacity : 1;
  var rotation = symbStyle.rotation !== void 0 ? symbStyle.rotation : 0;
  var vertContext = {
    inFragmentShader: false,
    variables: [],
    attributes: [],
    stringLiteralsMap: {},
    functions: {}
  };
  var parsedSize = expressionToGlsl(vertContext, size, ValueTypes.NUMBER_ARRAY | ValueTypes.NUMBER);
  var parsedOffset = expressionToGlsl(vertContext, offset, ValueTypes.NUMBER_ARRAY);
  var parsedTexCoord = expressionToGlsl(vertContext, texCoord, ValueTypes.NUMBER_ARRAY);
  var parsedRotation = expressionToGlsl(vertContext, rotation, ValueTypes.NUMBER);
  var fragContext = {
    inFragmentShader: true,
    variables: vertContext.variables,
    attributes: [],
    stringLiteralsMap: vertContext.stringLiteralsMap,
    functions: {}
  };
  var parsedColor = expressionToGlsl(fragContext, color, ValueTypes.COLOR);
  var parsedOpacity = expressionToGlsl(fragContext, opacity, ValueTypes.NUMBER);
  var opacityFilter = "1.0";
  var visibleSize = "vec2(".concat(expressionToGlsl(fragContext, size, ValueTypes.NUMBER_ARRAY | ValueTypes.NUMBER), ").x");
  switch (symbStyle.symbolType) {
    case "square":
      break;
    case "image":
      break;
    case "circle":
      opacityFilter = "(1.0-smoothstep(1.-4./".concat(visibleSize, ",1.,dot(v_quadCoord-.5,v_quadCoord-.5)*4.))");
      break;
    case "triangle":
      var st = "(v_quadCoord*2.-1.)";
      var a = "(atan(".concat(st, ".x,").concat(st, ".y))");
      opacityFilter = "(1.0-smoothstep(.5-3./".concat(visibleSize, ",.5,cos(floor(.5+").concat(a, "/2.094395102)*2.094395102-").concat(a, ")*length(").concat(st, ")))");
      break;
    default:
      throw new Error("Unexpected symbol type: " + symbStyle.symbolType);
  }
  var builder = new ShaderBuilder().setSizeExpression("vec2(".concat(parsedSize, ")")).setRotationExpression(parsedRotation).setSymbolOffsetExpression(parsedOffset).setTextureCoordinateExpression(parsedTexCoord).setSymbolRotateWithView(!!symbStyle.rotateWithView).setColorExpression("vec4(".concat(parsedColor, ".rgb, ").concat(parsedColor, ".a * ").concat(parsedOpacity, " * ").concat(opacityFilter, ")"));
  if (style.filter) {
    var parsedFilter = expressionToGlsl(fragContext, style.filter, ValueTypes.BOOLEAN);
    builder.setFragmentDiscardExpression("!".concat(parsedFilter));
  }
  var uniforms = {};
  fragContext.variables.forEach(function(varName) {
    var uniformName = uniformNameForVariable(varName);
    builder.addUniform("float ".concat(uniformName));
    uniforms[uniformName] = function() {
      if (!style.variables || style.variables[varName] === void 0) {
        throw new Error("The following variable is missing from the style: ".concat(varName));
      }
      var value = style.variables[varName];
      if (typeof value === "string") {
        value = getStringNumberEquivalent(vertContext, value);
      }
      return value !== void 0 ? value : -9999999;
    };
  });
  if (symbStyle.symbolType === "image" && symbStyle.src) {
    var texture = new Image();
    texture.crossOrigin = symbStyle.crossOrigin === void 0 ? "anonymous" : symbStyle.crossOrigin;
    texture.src = symbStyle.src;
    builder.addUniform("sampler2D u_texture").setColorExpression(builder.getColorExpression() + " * texture2D(u_texture, v_texCoord)");
    uniforms["u_texture"] = texture;
  }
  fragContext.attributes.forEach(function(attrName) {
    if (vertContext.attributes.indexOf(attrName) === -1) {
      vertContext.attributes.push(attrName);
    }
    builder.addVarying("v_".concat(attrName), "float", "a_".concat(attrName));
  });
  vertContext.attributes.forEach(function(attrName) {
    builder.addAttribute("float a_".concat(attrName));
  });
  return {
    builder,
    attributes: vertContext.attributes.map(function(attributeName) {
      return {
        name: attributeName,
        callback: function(feature, props) {
          var value = props[attributeName];
          if (typeof value === "string") {
            value = getStringNumberEquivalent(vertContext, value);
          }
          return value !== void 0 ? value : -9999999;
        }
      };
    }),
    uniforms
  };
}

// node_modules/ol/layer/WebGLPoints.js
var __extends4 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var WebGLPointsLayer = function(_super) {
  __extends4(WebGLPointsLayer2, _super);
  function WebGLPointsLayer2(options) {
    var _this = this;
    var baseOptions = assign({}, options);
    _this = _super.call(this, baseOptions) || this;
    _this.parseResult_ = parseLiteralStyle(options.style);
    _this.styleVariables_ = options.style.variables || {};
    _this.hitDetectionDisabled_ = !!options.disableHitDetection;
    return _this;
  }
  WebGLPointsLayer2.prototype.createRenderer = function() {
    return new PointsLayer_default(this, {
      vertexShader: this.parseResult_.builder.getSymbolVertexShader(),
      fragmentShader: this.parseResult_.builder.getSymbolFragmentShader(),
      hitVertexShader: !this.hitDetectionDisabled_ && this.parseResult_.builder.getSymbolVertexShader(true),
      hitFragmentShader: !this.hitDetectionDisabled_ && this.parseResult_.builder.getSymbolFragmentShader(true),
      uniforms: this.parseResult_.uniforms,
      attributes: this.parseResult_.attributes
    });
  };
  WebGLPointsLayer2.prototype.updateStyleVariables = function(variables) {
    assign(this.styleVariables_, variables);
    this.changed();
  };
  return WebGLPointsLayer2;
}(Layer_default);
var WebGLPoints_default = WebGLPointsLayer;

export {
  Uniforms,
  Attributes,
  TileLayer_default,
  ValueTypes,
  getStringNumberEquivalent,
  expressionToGlsl,
  uniformNameForVariable,
  PALETTE_TEXTURE_ARRAY,
  WebGLPoints_default
};
//# sourceMappingURL=chunk-FH33R4PM.js.map
