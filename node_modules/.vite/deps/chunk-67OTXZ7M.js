import {
  Feature_default as Feature_default2,
  transformGeometryWithOptions
} from "./chunk-XVWP6OCT.js";
import {
  GeometryCollection_default
} from "./chunk-B55ZFMWO.js";
import {
  FormatType_default
} from "./chunk-MWKHAX7O.js";
import {
  Feature_default
} from "./chunk-2J4CHPNI.js";
import {
  LineString_default,
  MultiLineString_default,
  MultiPoint_default,
  MultiPolygon_default
} from "./chunk-EVGQKXMZ.js";
import {
  Point_default,
  Polygon_default
} from "./chunk-5BXQLDDV.js";
import {
  get
} from "./chunk-SXHM4DXD.js";
import {
  GeometryType_default
} from "./chunk-BV5TMHXH.js";
import {
  assign,
  isEmpty
} from "./chunk-65SWW77D.js";
import {
  abstract,
  assert
} from "./chunk-2WYEPIST.js";

// node_modules/ol/format/JSONFeature.js
var __extends = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var JSONFeature = function(_super) {
  __extends(JSONFeature2, _super);
  function JSONFeature2() {
    return _super.call(this) || this;
  }
  JSONFeature2.prototype.getType = function() {
    return FormatType_default.JSON;
  };
  JSONFeature2.prototype.readFeature = function(source, opt_options) {
    return this.readFeatureFromObject(getObject(source), this.getReadOptions(source, opt_options));
  };
  JSONFeature2.prototype.readFeatures = function(source, opt_options) {
    return this.readFeaturesFromObject(getObject(source), this.getReadOptions(source, opt_options));
  };
  JSONFeature2.prototype.readFeatureFromObject = function(object, opt_options) {
    return abstract();
  };
  JSONFeature2.prototype.readFeaturesFromObject = function(object, opt_options) {
    return abstract();
  };
  JSONFeature2.prototype.readGeometry = function(source, opt_options) {
    return this.readGeometryFromObject(getObject(source), this.getReadOptions(source, opt_options));
  };
  JSONFeature2.prototype.readGeometryFromObject = function(object, opt_options) {
    return abstract();
  };
  JSONFeature2.prototype.readProjection = function(source) {
    return this.readProjectionFromObject(getObject(source));
  };
  JSONFeature2.prototype.readProjectionFromObject = function(object) {
    return abstract();
  };
  JSONFeature2.prototype.writeFeature = function(feature, opt_options) {
    return JSON.stringify(this.writeFeatureObject(feature, opt_options));
  };
  JSONFeature2.prototype.writeFeatureObject = function(feature, opt_options) {
    return abstract();
  };
  JSONFeature2.prototype.writeFeatures = function(features, opt_options) {
    return JSON.stringify(this.writeFeaturesObject(features, opt_options));
  };
  JSONFeature2.prototype.writeFeaturesObject = function(features, opt_options) {
    return abstract();
  };
  JSONFeature2.prototype.writeGeometry = function(geometry, opt_options) {
    return JSON.stringify(this.writeGeometryObject(geometry, opt_options));
  };
  JSONFeature2.prototype.writeGeometryObject = function(geometry, opt_options) {
    return abstract();
  };
  return JSONFeature2;
}(Feature_default2);
function getObject(source) {
  if (typeof source === "string") {
    var object = JSON.parse(source);
    return object ? object : null;
  } else if (source !== null) {
    return source;
  } else {
    return null;
  }
}
var JSONFeature_default = JSONFeature;

// node_modules/ol/format/GeoJSON.js
var __extends2 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var GeoJSON = function(_super) {
  __extends2(GeoJSON2, _super);
  function GeoJSON2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    _this = _super.call(this) || this;
    _this.dataProjection = get(options.dataProjection ? options.dataProjection : "EPSG:4326");
    if (options.featureProjection) {
      _this.defaultFeatureProjection = get(options.featureProjection);
    }
    _this.geometryName_ = options.geometryName;
    _this.extractGeometryName_ = options.extractGeometryName;
    _this.supportedMediaTypes = [
      "application/geo+json",
      "application/vnd.geo+json"
    ];
    return _this;
  }
  GeoJSON2.prototype.readFeatureFromObject = function(object, opt_options) {
    var geoJSONFeature = null;
    if (object["type"] === "Feature") {
      geoJSONFeature = object;
    } else {
      geoJSONFeature = {
        "type": "Feature",
        "geometry": object,
        "properties": null
      };
    }
    var geometry = readGeometry(geoJSONFeature["geometry"], opt_options);
    var feature = new Feature_default();
    if (this.geometryName_) {
      feature.setGeometryName(this.geometryName_);
    } else if (this.extractGeometryName_ && "geometry_name" in geoJSONFeature !== void 0) {
      feature.setGeometryName(geoJSONFeature["geometry_name"]);
    }
    feature.setGeometry(geometry);
    if ("id" in geoJSONFeature) {
      feature.setId(geoJSONFeature["id"]);
    }
    if (geoJSONFeature["properties"]) {
      feature.setProperties(geoJSONFeature["properties"], true);
    }
    return feature;
  };
  GeoJSON2.prototype.readFeaturesFromObject = function(object, opt_options) {
    var geoJSONObject = object;
    var features = null;
    if (geoJSONObject["type"] === "FeatureCollection") {
      var geoJSONFeatureCollection = object;
      features = [];
      var geoJSONFeatures = geoJSONFeatureCollection["features"];
      for (var i = 0, ii = geoJSONFeatures.length; i < ii; ++i) {
        features.push(this.readFeatureFromObject(geoJSONFeatures[i], opt_options));
      }
    } else {
      features = [this.readFeatureFromObject(object, opt_options)];
    }
    return features;
  };
  GeoJSON2.prototype.readGeometryFromObject = function(object, opt_options) {
    return readGeometry(object, opt_options);
  };
  GeoJSON2.prototype.readProjectionFromObject = function(object) {
    var crs = object["crs"];
    var projection;
    if (crs) {
      if (crs["type"] == "name") {
        projection = get(crs["properties"]["name"]);
      } else if (crs["type"] === "EPSG") {
        projection = get("EPSG:" + crs["properties"]["code"]);
      } else {
        assert(false, 36);
      }
    } else {
      projection = this.dataProjection;
    }
    return projection;
  };
  GeoJSON2.prototype.writeFeatureObject = function(feature, opt_options) {
    opt_options = this.adaptOptions(opt_options);
    var object = {
      "type": "Feature",
      geometry: null,
      properties: null
    };
    var id = feature.getId();
    if (id !== void 0) {
      object.id = id;
    }
    if (!feature.hasProperties()) {
      return object;
    }
    var properties = feature.getProperties();
    var geometry = feature.getGeometry();
    if (geometry) {
      object.geometry = writeGeometry(geometry, opt_options);
      delete properties[feature.getGeometryName()];
    }
    if (!isEmpty(properties)) {
      object.properties = properties;
    }
    return object;
  };
  GeoJSON2.prototype.writeFeaturesObject = function(features, opt_options) {
    opt_options = this.adaptOptions(opt_options);
    var objects = [];
    for (var i = 0, ii = features.length; i < ii; ++i) {
      objects.push(this.writeFeatureObject(features[i], opt_options));
    }
    return {
      type: "FeatureCollection",
      features: objects
    };
  };
  GeoJSON2.prototype.writeGeometryObject = function(geometry, opt_options) {
    return writeGeometry(geometry, this.adaptOptions(opt_options));
  };
  return GeoJSON2;
}(JSONFeature_default);
function readGeometry(object, opt_options) {
  if (!object) {
    return null;
  }
  var geometry;
  switch (object["type"]) {
    case GeometryType_default.POINT: {
      geometry = readPointGeometry(object);
      break;
    }
    case GeometryType_default.LINE_STRING: {
      geometry = readLineStringGeometry(object);
      break;
    }
    case GeometryType_default.POLYGON: {
      geometry = readPolygonGeometry(object);
      break;
    }
    case GeometryType_default.MULTI_POINT: {
      geometry = readMultiPointGeometry(object);
      break;
    }
    case GeometryType_default.MULTI_LINE_STRING: {
      geometry = readMultiLineStringGeometry(object);
      break;
    }
    case GeometryType_default.MULTI_POLYGON: {
      geometry = readMultiPolygonGeometry(object);
      break;
    }
    case GeometryType_default.GEOMETRY_COLLECTION: {
      geometry = readGeometryCollectionGeometry(object);
      break;
    }
    default: {
      throw new Error("Unsupported GeoJSON type: " + object.type);
    }
  }
  return transformGeometryWithOptions(geometry, false, opt_options);
}
function readGeometryCollectionGeometry(object, opt_options) {
  var geometries = object["geometries"].map(function(geometry) {
    return readGeometry(geometry, opt_options);
  });
  return new GeometryCollection_default(geometries);
}
function readPointGeometry(object) {
  return new Point_default(object["coordinates"]);
}
function readLineStringGeometry(object) {
  return new LineString_default(object["coordinates"]);
}
function readMultiLineStringGeometry(object) {
  return new MultiLineString_default(object["coordinates"]);
}
function readMultiPointGeometry(object) {
  return new MultiPoint_default(object["coordinates"]);
}
function readMultiPolygonGeometry(object) {
  return new MultiPolygon_default(object["coordinates"]);
}
function readPolygonGeometry(object) {
  return new Polygon_default(object["coordinates"]);
}
function writeGeometry(geometry, opt_options) {
  geometry = transformGeometryWithOptions(geometry, true, opt_options);
  var type = geometry.getType();
  var geoJSON;
  switch (type) {
    case GeometryType_default.POINT: {
      geoJSON = writePointGeometry(geometry, opt_options);
      break;
    }
    case GeometryType_default.LINE_STRING: {
      geoJSON = writeLineStringGeometry(geometry, opt_options);
      break;
    }
    case GeometryType_default.POLYGON: {
      geoJSON = writePolygonGeometry(geometry, opt_options);
      break;
    }
    case GeometryType_default.MULTI_POINT: {
      geoJSON = writeMultiPointGeometry(geometry, opt_options);
      break;
    }
    case GeometryType_default.MULTI_LINE_STRING: {
      geoJSON = writeMultiLineStringGeometry(geometry, opt_options);
      break;
    }
    case GeometryType_default.MULTI_POLYGON: {
      geoJSON = writeMultiPolygonGeometry(geometry, opt_options);
      break;
    }
    case GeometryType_default.GEOMETRY_COLLECTION: {
      geoJSON = writeGeometryCollectionGeometry(geometry, opt_options);
      break;
    }
    case GeometryType_default.CIRCLE: {
      geoJSON = {
        type: "GeometryCollection",
        geometries: []
      };
      break;
    }
    default: {
      throw new Error("Unsupported geometry type: " + type);
    }
  }
  return geoJSON;
}
function writeGeometryCollectionGeometry(geometry, opt_options) {
  var geometries = geometry.getGeometriesArray().map(function(geometry2) {
    var options = assign({}, opt_options);
    delete options.featureProjection;
    return writeGeometry(geometry2, options);
  });
  return {
    type: "GeometryCollection",
    geometries
  };
}
function writeLineStringGeometry(geometry, opt_options) {
  return {
    type: "LineString",
    coordinates: geometry.getCoordinates()
  };
}
function writeMultiLineStringGeometry(geometry, opt_options) {
  return {
    type: "MultiLineString",
    coordinates: geometry.getCoordinates()
  };
}
function writeMultiPointGeometry(geometry, opt_options) {
  return {
    type: "MultiPoint",
    coordinates: geometry.getCoordinates()
  };
}
function writeMultiPolygonGeometry(geometry, opt_options) {
  var right;
  if (opt_options) {
    right = opt_options.rightHanded;
  }
  return {
    type: "MultiPolygon",
    coordinates: geometry.getCoordinates(right)
  };
}
function writePointGeometry(geometry, opt_options) {
  return {
    type: "Point",
    coordinates: geometry.getCoordinates()
  };
}
function writePolygonGeometry(geometry, opt_options) {
  var right;
  if (opt_options) {
    right = opt_options.rightHanded;
  }
  return {
    type: "Polygon",
    coordinates: geometry.getCoordinates(right)
  };
}
var GeoJSON_default = GeoJSON;

export {
  GeoJSON_default
};
//# sourceMappingURL=chunk-67OTXZ7M.js.map
