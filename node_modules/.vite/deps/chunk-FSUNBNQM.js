import {
  UrlTile_default,
  createForProjection,
  createXYZ,
  extentFromProjection
} from "./chunk-XJHEPK5C.js";
import {
  VectorRenderTile_default,
  VectorTile_default
} from "./chunk-QNTHNCMB.js";
import {
  TileCache_default
} from "./chunk-XJ3UTWUB.js";
import {
  fromKey,
  getCacheKeyForTileKey,
  getKeyZXY
} from "./chunk-N3WJGJXL.js";
import {
  loadFeaturesXhr
} from "./chunk-XRE2H656.js";
import {
  TileState_default
} from "./chunk-TTYWGBB4.js";
import {
  toSize
} from "./chunk-52GDN6Z5.js";
import {
  EventType_default
} from "./chunk-POSIMZXH.js";
import {
  isEmpty
} from "./chunk-65SWW77D.js";
import {
  buffer,
  getIntersection,
  intersects
} from "./chunk-4LIZYYTK.js";

// node_modules/ol/source/VectorTile.js
var __extends = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var VectorTile = function(_super) {
  __extends(VectorTile2, _super);
  function VectorTile2(options) {
    var _this = this;
    var projection = options.projection || "EPSG:3857";
    var extent = options.extent || extentFromProjection(projection);
    var tileGrid = options.tileGrid || createXYZ({
      extent,
      maxResolution: options.maxResolution,
      maxZoom: options.maxZoom !== void 0 ? options.maxZoom : 22,
      minZoom: options.minZoom,
      tileSize: options.tileSize || 512
    });
    _this = _super.call(this, {
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      cacheSize: options.cacheSize,
      interpolate: true,
      opaque: false,
      projection,
      state: options.state,
      tileGrid,
      tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultLoadFunction,
      tileUrlFunction: options.tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX === void 0 ? true : options.wrapX,
      transition: options.transition,
      zDirection: options.zDirection === void 0 ? 1 : options.zDirection
    }) || this;
    _this.format_ = options.format ? options.format : null;
    _this.sourceTileCache = new TileCache_default(_this.tileCache.highWaterMark);
    _this.overlaps_ = options.overlaps == void 0 ? true : options.overlaps;
    _this.tileClass = options.tileClass ? options.tileClass : VectorTile_default;
    _this.tileGrids_ = {};
    return _this;
  }
  VectorTile2.prototype.getFeaturesInExtent = function(extent) {
    var features = [];
    var tileCache = this.tileCache;
    if (tileCache.getCount() === 0) {
      return features;
    }
    var z = fromKey(tileCache.peekFirstKey())[0];
    var tileGrid = this.tileGrid;
    tileCache.forEach(function(tile) {
      if (tile.tileCoord[0] !== z || tile.getState() !== TileState_default.LOADED) {
        return;
      }
      var sourceTiles = tile.getSourceTiles();
      for (var i = 0, ii = sourceTiles.length; i < ii; ++i) {
        var sourceTile = sourceTiles[i];
        var tileCoord = sourceTile.tileCoord;
        if (intersects(extent, tileGrid.getTileCoordExtent(tileCoord))) {
          var tileFeatures = sourceTile.getFeatures();
          if (tileFeatures) {
            for (var j = 0, jj = tileFeatures.length; j < jj; ++j) {
              var candidate = tileFeatures[j];
              var geometry = candidate.getGeometry();
              if (intersects(extent, geometry.getExtent())) {
                features.push(candidate);
              }
            }
          }
        }
      }
    });
    return features;
  };
  VectorTile2.prototype.getOverlaps = function() {
    return this.overlaps_;
  };
  VectorTile2.prototype.clear = function() {
    this.tileCache.clear();
    this.sourceTileCache.clear();
  };
  VectorTile2.prototype.expireCache = function(projection, usedTiles) {
    var tileCache = this.getTileCacheForProjection(projection);
    var usedSourceTiles = Object.keys(usedTiles).reduce(function(acc, key) {
      var cacheKey = getCacheKeyForTileKey(key);
      if (tileCache.containsKey(cacheKey)) {
        var sourceTiles = tileCache.get(cacheKey).sourceTiles;
        for (var i = 0, ii = sourceTiles.length; i < ii; ++i) {
          acc[sourceTiles[i].getKey()] = true;
        }
      }
      return acc;
    }, {});
    _super.prototype.expireCache.call(this, projection, usedTiles);
    this.sourceTileCache.expireCache(usedSourceTiles);
  };
  VectorTile2.prototype.getSourceTiles = function(pixelRatio, projection, tile) {
    var _this = this;
    if (tile.getState() === TileState_default.IDLE) {
      tile.setState(TileState_default.LOADING);
      var urlTileCoord = tile.wrappedTileCoord;
      var tileGrid = this.getTileGridForProjection(projection);
      var extent = tileGrid.getTileCoordExtent(urlTileCoord);
      var z = urlTileCoord[0];
      var resolution = tileGrid.getResolution(z);
      buffer(extent, -resolution, extent);
      var sourceTileGrid_1 = this.tileGrid;
      var sourceExtent = sourceTileGrid_1.getExtent();
      if (sourceExtent) {
        getIntersection(extent, sourceExtent, extent);
      }
      var sourceZ = sourceTileGrid_1.getZForResolution(resolution, 1);
      sourceTileGrid_1.forEachTileCoord(extent, sourceZ, function(sourceTileCoord) {
        var tileUrl = _this.tileUrlFunction(sourceTileCoord, pixelRatio, projection);
        var sourceTile = _this.sourceTileCache.containsKey(tileUrl) ? _this.sourceTileCache.get(tileUrl) : new _this.tileClass(sourceTileCoord, tileUrl ? TileState_default.IDLE : TileState_default.EMPTY, tileUrl, _this.format_, _this.tileLoadFunction);
        tile.sourceTiles.push(sourceTile);
        var sourceTileState = sourceTile.getState();
        if (sourceTileState < TileState_default.LOADED) {
          var listenChange_1 = function(event) {
            _this.handleTileChange(event);
            var state = sourceTile.getState();
            if (state === TileState_default.LOADED || state === TileState_default.ERROR) {
              var sourceTileKey = sourceTile.getKey();
              if (sourceTileKey in tile.errorTileKeys) {
                if (sourceTile.getState() === TileState_default.LOADED) {
                  delete tile.errorTileKeys[sourceTileKey];
                }
              } else {
                tile.loadingSourceTiles--;
              }
              if (state === TileState_default.ERROR) {
                tile.errorTileKeys[sourceTileKey] = true;
              } else {
                sourceTile.removeEventListener(EventType_default.CHANGE, listenChange_1);
              }
              if (tile.loadingSourceTiles === 0) {
                tile.setState(isEmpty(tile.errorTileKeys) ? TileState_default.LOADED : TileState_default.ERROR);
              }
            }
          };
          sourceTile.addEventListener(EventType_default.CHANGE, listenChange_1);
          tile.loadingSourceTiles++;
        }
        if (sourceTileState === TileState_default.IDLE) {
          sourceTile.extent = sourceTileGrid_1.getTileCoordExtent(sourceTileCoord);
          sourceTile.projection = projection;
          sourceTile.resolution = sourceTileGrid_1.getResolution(sourceTileCoord[0]);
          _this.sourceTileCache.set(tileUrl, sourceTile);
          sourceTile.load();
        }
      });
      if (!tile.loadingSourceTiles) {
        tile.setState(tile.sourceTiles.some(function(sourceTile) {
          return sourceTile.getState() === TileState_default.ERROR;
        }) ? TileState_default.ERROR : TileState_default.LOADED);
      }
    }
    return tile.sourceTiles;
  };
  VectorTile2.prototype.getTile = function(z, x, y, pixelRatio, projection) {
    var coordKey = getKeyZXY(z, x, y);
    var key = this.getKey();
    var tile;
    if (this.tileCache.containsKey(coordKey)) {
      tile = this.tileCache.get(coordKey);
      if (tile.key === key) {
        return tile;
      }
    }
    var tileCoord = [z, x, y];
    var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
    var sourceExtent = this.getTileGrid().getExtent();
    var tileGrid = this.getTileGridForProjection(projection);
    if (urlTileCoord && sourceExtent) {
      var tileExtent = tileGrid.getTileCoordExtent(urlTileCoord);
      buffer(tileExtent, -tileGrid.getResolution(z), tileExtent);
      if (!intersects(sourceExtent, tileExtent)) {
        urlTileCoord = null;
      }
    }
    var empty = true;
    if (urlTileCoord !== null) {
      var sourceTileGrid = this.tileGrid;
      var resolution = tileGrid.getResolution(z);
      var sourceZ = sourceTileGrid.getZForResolution(resolution, 1);
      var extent = tileGrid.getTileCoordExtent(urlTileCoord);
      buffer(extent, -resolution, extent);
      sourceTileGrid.forEachTileCoord(extent, sourceZ, function(sourceTileCoord) {
        empty = empty && !this.tileUrlFunction(sourceTileCoord, pixelRatio, projection);
      }.bind(this));
    }
    var newTile = new VectorRenderTile_default(tileCoord, empty ? TileState_default.EMPTY : TileState_default.IDLE, urlTileCoord, this.getSourceTiles.bind(this, pixelRatio, projection));
    newTile.key = key;
    if (tile) {
      newTile.interimTile = tile;
      newTile.refreshInterimChain();
      this.tileCache.replace(coordKey, newTile);
    } else {
      this.tileCache.set(coordKey, newTile);
    }
    return newTile;
  };
  VectorTile2.prototype.getTileGridForProjection = function(projection) {
    var code = projection.getCode();
    var tileGrid = this.tileGrids_[code];
    if (!tileGrid) {
      var sourceTileGrid = this.tileGrid;
      tileGrid = createForProjection(projection, void 0, sourceTileGrid ? sourceTileGrid.getTileSize(sourceTileGrid.getMinZoom()) : void 0);
      this.tileGrids_[code] = tileGrid;
    }
    return tileGrid;
  };
  VectorTile2.prototype.getTilePixelRatio = function(pixelRatio) {
    return pixelRatio;
  };
  VectorTile2.prototype.getTilePixelSize = function(z, pixelRatio, projection) {
    var tileGrid = this.getTileGridForProjection(projection);
    var tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);
    return [
      Math.round(tileSize[0] * pixelRatio),
      Math.round(tileSize[1] * pixelRatio)
    ];
  };
  VectorTile2.prototype.updateCacheSize = function(tileCount, projection) {
    _super.prototype.updateCacheSize.call(this, tileCount * 2, projection);
    this.sourceTileCache.highWaterMark = this.getTileCacheForProjection(projection).highWaterMark;
  };
  return VectorTile2;
}(UrlTile_default);
var VectorTile_default2 = VectorTile;
function defaultLoadFunction(tile, url) {
  tile.setLoader(function(extent, resolution, projection) {
    loadFeaturesXhr(url, tile.getFormat(), extent, resolution, projection, tile.onLoad.bind(tile), tile.onError.bind(tile));
  });
}

export {
  VectorTile_default2 as VectorTile_default,
  defaultLoadFunction
};
//# sourceMappingURL=chunk-FSUNBNQM.js.map
