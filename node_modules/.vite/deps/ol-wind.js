import "./chunk-UPNSRDPA.js";
import "./chunk-FSUNBNQM.js";
import "./chunk-CAZ5RT5T.js";
import "./chunk-XJHEPK5C.js";
import "./chunk-IQVIUSXF.js";
import "./chunk-RUSIYHV2.js";
import "./chunk-72DZJRRO.js";
import "./chunk-IGD25YNA.js";
import "./chunk-E5GLDD3O.js";
import "./chunk-FH33R4PM.js";
import "./chunk-XO5TAQGF.js";
import "./chunk-6TRFZY4T.js";
import "./chunk-67OTXZ7M.js";
import "./chunk-OL3JUVAL.js";
import "./chunk-XVWP6OCT.js";
import "./chunk-OVVP6TIC.js";
import "./chunk-B55ZFMWO.js";
import "./chunk-IJ5BG3YS.js";
import "./chunk-QNTHNCMB.js";
import "./chunk-X3MHNUIL.js";
import "./chunk-XJ3UTWUB.js";
import "./chunk-WPDST7KJ.js";
import "./chunk-N3WJGJXL.js";
import "./chunk-G62ODYDV.js";
import "./chunk-ZVEBQB7G.js";
import "./chunk-KE2T25IH.js";
import "./chunk-ZPP4SNOR.js";
import "./chunk-A24BHASK.js";
import "./chunk-G6FNESFC.js";
import "./chunk-Y55O4VOG.js";
import "./chunk-XRE2H656.js";
import "./chunk-5UFM47PT.js";
import "./chunk-DNZESCKH.js";
import "./chunk-P2XNXQZP.js";
import "./chunk-RBDOL7K2.js";
import "./chunk-X5H7V2WG.js";
import "./chunk-Y4UODQ4X.js";
import "./chunk-HVSYABL5.js";
import "./chunk-Y2LQGI2R.js";
import "./chunk-LVYKA657.js";
import "./chunk-GP7DSN2R.js";
import "./chunk-TLG5772Y.js";
import "./chunk-MWKHAX7O.js";
import "./chunk-2J4CHPNI.js";
import "./chunk-CM3XQLP2.js";
import "./chunk-EVGQKXMZ.js";
import "./chunk-SY3JX5TH.js";
import "./chunk-KKUTS3CC.js";
import {
  Layer_default as Layer_default2
} from "./chunk-RUJGCJNR.js";
import "./chunk-RELS262I.js";
import "./chunk-BULJNUPF.js";
import "./chunk-GZT7WK3M.js";
import "./chunk-XAFSPYPF.js";
import "./chunk-OWHWYXAG.js";
import "./chunk-LJGIG2JF.js";
import "./chunk-R7HSF55M.js";
import "./chunk-JCANJS6I.js";
import "./chunk-MIW245NA.js";
import "./chunk-QHUPX7D7.js";
import "./chunk-TPBBA3TB.js";
import "./chunk-TTYWGBB4.js";
import "./chunk-5VJ7SCNZ.js";
import "./chunk-2PC4IXGT.js";
import "./chunk-O3QDXGVC.js";
import "./chunk-24OILLYA.js";
import "./chunk-NPKFM3HM.js";
import "./chunk-JW2HU6RF.js";
import "./chunk-52GDN6Z5.js";
import "./chunk-4J5GOOLB.js";
import {
  Layer_default
} from "./chunk-TBAL5KHY.js";
import "./chunk-RMQQ5XY2.js";
import "./chunk-5BXQLDDV.js";
import "./chunk-4MEYLJCU.js";
import "./chunk-B6ZS5XHK.js";
import "./chunk-OIGY3JBW.js";
import "./chunk-HPBH6HWH.js";
import {
  fromUserCoordinate,
  fromUserExtent,
  toUserCoordinate,
  transform
} from "./chunk-SXHM4DXD.js";
import "./chunk-XDIKTJFU.js";
import {
  apply,
  create,
  makeInverse,
  makeScale,
  setFromArray,
  toString as toString2
} from "./chunk-HQZSRF55.js";
import "./chunk-22ZMPUOM.js";
import "./chunk-BV5TMHXH.js";
import "./chunk-RDSLTYQF.js";
import "./chunk-J5KXJ44D.js";
import "./chunk-POSIMZXH.js";
import "./chunk-65SWW77D.js";
import "./chunk-IUTEOIRK.js";
import {
  containsCoordinate,
  containsExtent,
  getIntersection,
  intersects,
  isEmpty
} from "./chunk-4LIZYYTK.js";
import "./chunk-6G6NVFIA.js";
import "./chunk-2WYEPIST.js";
import "./chunk-TSM2WJGQ.js";
import "./chunk-QLLZOWC4.js";

// node_modules/ol-wind/dist/ol-wind.esm.js
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function equals(arr1, arr2) {
  var len1 = arr1.length;
  if (len1 !== arr2.length) {
    return false;
  }
  for (var i = 0; i < len1; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }
  return true;
}
function __spreadArrays() {
  var arguments$1 = arguments;
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) {
    s += arguments$1[i].length;
  }
  for (var r = Array(s), k = 0, i = 0; i < il; i++) {
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {
      r[k] = a[j];
    }
  }
  return r;
}
if (!Array.isArray) {
  Array.isArray = function(arg) {
    return Object.prototype.toString.call(arg) === "[object Array]";
  };
}
if (typeof Object.assign != "function") {
  Object.defineProperty(Object, "assign", {
    value: function assign2(target, varArgs) {
      var arguments$1 = arguments;
      if (target == null) {
        throw new TypeError("Cannot convert undefined or null to object");
      }
      var to = Object(target);
      for (var index = 1; index < arguments.length; index++) {
        var nextSource = arguments$1[index];
        if (nextSource != null) {
          for (var nextKey in nextSource) {
            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
      return to;
    },
    writable: true,
    configurable: true
  });
}
var hasOwnProperty = Object.prototype.hasOwnProperty;
var symToStringTag = typeof Symbol !== "undefined" ? Symbol.toStringTag : void 0;
function baseGetTag(value) {
  if (value === null) {
    return value === void 0 ? "[object Undefined]" : "[object Null]";
  }
  if (!(symToStringTag && symToStringTag in Object(value))) {
    return toString.call(value);
  }
  var isOwn = hasOwnProperty.call(value, symToStringTag);
  var tag = value[symToStringTag];
  var unmasked = false;
  try {
    value[symToStringTag] = void 0;
    unmasked = true;
  } catch (e) {
  }
  var result = Object.prototype.toString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  var tag = baseGetTag(value);
  return tag === "[object Function]" || tag === "[object AsyncFunction]" || tag === "[object GeneratorFunction]" || tag === "[object Proxy]";
}
function isObject(value) {
  var type = typeof value;
  return value !== null && (type === "object" || type === "function");
}
function isString(value) {
  if (value == null) {
    return false;
  }
  return typeof value === "string" || value.constructor !== null && value.constructor === String;
}
function isNumber(value) {
  return Object.prototype.toString.call(value) === "[object Number]" && !isNaN(value);
}
function isArray(arr) {
  return Array.isArray(arr);
}
function assign(target) {
  var arguments$1 = arguments;
  var sources = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    sources[_i - 1] = arguments$1[_i];
  }
  return Object.assign.apply(Object, __spreadArrays([target], sources));
}
function warnLog(msg) {
  console.warn("wind-layer: " + msg);
}
function floorMod(a, n) {
  return a - n * Math.floor(a / n);
}
function isValide(val) {
  return val !== void 0 && val !== null && !isNaN(val);
}
function formatData(data) {
  var uComp;
  var vComp;
  {
    console.time("format-data");
  }
  data.forEach(function(record) {
    switch (record.header.parameterCategory + "," + record.header.parameterNumber) {
      case "1,2":
      case "2,2":
        uComp = record;
        break;
      case "1,3":
      case "2,3":
        vComp = record;
        break;
    }
  });
  if (!vComp || !uComp) {
    return;
  }
  var header = uComp.header;
  var vectorField = new Field({
    xmin: header.lo1,
    ymin: header.la1,
    xmax: header.lo2,
    ymax: header.la2,
    deltaX: header.dx,
    deltaY: header.dy,
    cols: header.nx,
    rows: header.ny,
    us: uComp.data,
    vs: vComp.data
  });
  {
    console.timeEnd("format-data");
  }
  return vectorField;
}
var Vector = function() {
  function Vector2(u, v) {
    this.u = u;
    this.v = v;
    this.m = this.magnitude();
  }
  Vector2.prototype.magnitude = function() {
    return Math.sqrt(this.u * this.u + this.v * this.v);
  };
  Vector2.prototype.directionTo = function() {
    var verticalAngle = Math.atan2(this.u, this.v);
    var inDegrees = verticalAngle * (180 / Math.PI);
    if (inDegrees < 0) {
      inDegrees += 360;
    }
    return inDegrees;
  };
  Vector2.prototype.directionFrom = function() {
    var a = this.directionTo();
    return (a + 180) % 360;
  };
  return Vector2;
}();
var Field = function() {
  function Field2(params) {
    this.grid = [];
    this.xmin = params.xmin;
    this.xmax = params.xmax;
    this.ymin = params.ymin;
    this.ymax = params.ymax;
    this.cols = params.cols;
    this.rows = params.rows;
    this.us = params.us;
    this.vs = params.vs;
    this.deltaX = params.deltaX;
    this.deltaY = params.deltaY;
    if (this.deltaY < 0 && this.ymin < this.ymax) {
      console.warn("[wind-core]: The data is flipY");
    } else {
      this.ymin = Math.min(params.ymax, params.ymin);
      this.ymax = Math.max(params.ymax, params.ymin);
    }
    this.isFields = true;
    var cols = Math.ceil((this.xmax - this.xmin) / params.deltaX);
    var rows = Math.ceil((this.ymax - this.ymin) / params.deltaY);
    if (cols !== this.cols || rows !== this.rows) {
      console.warn("[wind-core]: The data grid not equal");
    }
    this.isContinuous = Math.floor(this.cols * params.deltaX) >= 360;
    this.wrappedX = "wrappedX" in params ? params.wrappedX : this.xmax > 180;
    this.grid = this.buildGrid();
    this.range = this.calculateRange();
  }
  Field2.prototype.buildGrid = function() {
    var grid = [];
    var p = 0;
    var _a = this, rows = _a.rows, cols = _a.cols, us = _a.us, vs = _a.vs;
    for (var j = 0; j < rows; j++) {
      var row = [];
      for (var i = 0; i < cols; i++, p++) {
        var u = us[p];
        var v = vs[p];
        var valid = this.isValid(u) && this.isValid(v);
        row[i] = valid ? new Vector(u, v) : null;
      }
      if (this.isContinuous) {
        row.push(row[0]);
      }
      grid[j] = row;
    }
    return grid;
  };
  Field2.prototype.release = function() {
    this.grid = [];
  };
  Field2.prototype.extent = function() {
    return [
      this.xmin,
      this.ymin,
      this.xmax,
      this.ymax
    ];
  };
  Field2.prototype.bilinearInterpolateVector = function(x, y, g00, g10, g01, g11) {
    var rx = 1 - x;
    var ry = 1 - y;
    var a = rx * ry;
    var b = x * ry;
    var c = rx * y;
    var d = x * y;
    var u = g00.u * a + g10.u * b + g01.u * c + g11.u * d;
    var v = g00.v * a + g10.v * b + g01.v * c + g11.v * d;
    return new Vector(u, v);
  };
  Field2.prototype.calculateRange = function() {
    if (!this.grid || !this.grid[0]) {
      return;
    }
    var rows = this.grid.length;
    var cols = this.grid[0].length;
    var min;
    var max;
    for (var j = 0; j < rows; j++) {
      for (var i = 0; i < cols; i++) {
        var vec = this.grid[j][i];
        if (vec !== null) {
          var val = vec.m || vec.magnitude();
          if (min === void 0) {
            min = val;
          } else if (max === void 0) {
            max = val;
            min = Math.min(min, max);
            max = Math.max(min, max);
          } else {
            min = Math.min(val, min);
            max = Math.max(val, max);
          }
        }
      }
    }
    return [min, max];
  };
  Field2.prototype.isValid = function(x) {
    return x !== null && x !== void 0;
  };
  Field2.prototype.getWrappedLongitudes = function() {
    var xmin = this.xmin;
    var xmax = this.xmax;
    if (this.wrappedX) {
      if (this.isContinuous) {
        xmin = -180;
        xmax = 180;
      } else {
        xmax = this.xmax - 360;
        xmin = this.xmin - 360;
      }
    }
    return [xmin, xmax];
  };
  Field2.prototype.contains = function(lon, lat) {
    var _a = this.getWrappedLongitudes(), xmin = _a[0], xmax = _a[1];
    var longitudeIn = lon >= xmin && lon <= xmax;
    var latitudeIn;
    if (this.deltaY >= 0) {
      latitudeIn = lat >= this.ymin && lat <= this.ymax;
    } else {
      latitudeIn = lat >= this.ymax && lat <= this.ymin;
    }
    return longitudeIn && latitudeIn;
  };
  Field2.prototype.getDecimalIndexes = function(lon, lat) {
    var i = floorMod(lon - this.xmin, 360) / this.deltaX;
    var j = (this.ymax - lat) / this.deltaY;
    return [i, j];
  };
  Field2.prototype.valueAt = function(lon, lat) {
    if (!this.contains(lon, lat)) {
      return null;
    }
    var indexes = this.getDecimalIndexes(lon, lat);
    var ii = Math.floor(indexes[0]);
    var jj = Math.floor(indexes[1]);
    var ci = this.clampColumnIndex(ii);
    var cj = this.clampRowIndex(jj);
    return this.valueAtIndexes(ci, cj);
  };
  Field2.prototype.interpolatedValueAt = function(lon, lat) {
    if (!this.contains(lon, lat)) {
      return null;
    }
    var _a = this.getDecimalIndexes(lon, lat), i = _a[0], j = _a[1];
    return this.interpolatePoint(i, j);
  };
  Field2.prototype.hasValueAt = function(lon, lat) {
    var value = this.valueAt(lon, lat);
    return value !== null;
  };
  Field2.prototype.interpolatePoint = function(i, j) {
    var indexes = this.getFourSurroundingIndexes(i, j);
    var fi = indexes[0], ci = indexes[1], fj = indexes[2], cj = indexes[3];
    var values = this.getFourSurroundingValues(fi, ci, fj, cj);
    if (values) {
      var g00 = values[0], g10 = values[1], g01 = values[2], g11 = values[3];
      return this.bilinearInterpolateVector(i - fi, j - fj, g00, g10, g01, g11);
    }
    return null;
  };
  Field2.prototype.clampColumnIndex = function(ii) {
    var i = ii;
    if (ii < 0) {
      i = 0;
    }
    var maxCol = this.cols - 1;
    if (ii > maxCol) {
      i = maxCol;
    }
    return i;
  };
  Field2.prototype.clampRowIndex = function(jj) {
    var j = jj;
    if (jj < 0) {
      j = 0;
    }
    var maxRow = this.rows - 1;
    if (jj > maxRow) {
      j = maxRow;
    }
    return j;
  };
  Field2.prototype.getFourSurroundingIndexes = function(i, j) {
    var fi = Math.floor(i);
    var ci = fi + 1;
    if (this.isContinuous && ci >= this.cols) {
      ci = 0;
    }
    ci = this.clampColumnIndex(ci);
    var fj = this.clampRowIndex(Math.floor(j));
    var cj = this.clampRowIndex(fj + 1);
    return [fi, ci, fj, cj];
  };
  Field2.prototype.getFourSurroundingValues = function(fi, ci, fj, cj) {
    var row;
    if (row = this.grid[fj]) {
      var g00 = row[fi];
      var g10 = row[ci];
      if (this.isValid(g00) && this.isValid(g10) && (row = this.grid[cj])) {
        var g01 = row[fi];
        var g11 = row[ci];
        if (this.isValid(g01) && this.isValid(g11)) {
          return [g00, g10, g01, g11];
        }
      }
    }
    return null;
  };
  Field2.prototype.valueAtIndexes = function(i, j) {
    return this.grid[j][i];
  };
  Field2.prototype.lonLatAtIndexes = function(i, j) {
    var lon = this.longitudeAtX(i);
    var lat = this.latitudeAtY(j);
    return [lon, lat];
  };
  Field2.prototype.longitudeAtX = function(i) {
    var halfXPixel = this.deltaX / 2;
    var lon = this.xmin + halfXPixel + i * this.deltaX;
    if (this.wrappedX) {
      lon = lon > 180 ? lon - 360 : lon;
    }
    return lon;
  };
  Field2.prototype.latitudeAtY = function(j) {
    var halfYPixel = this.deltaY / 2;
    return this.ymax - halfYPixel - j * this.deltaY;
  };
  Field2.prototype.randomize = function(o, width, height, unproject) {
    if (o === void 0) {
      o = {};
    }
    var i = Math.random() * (width || this.cols) | 0;
    var j = Math.random() * (height || this.rows) | 0;
    var coords = unproject([i, j]);
    if (coords !== null) {
      o.x = coords[0];
      o.y = coords[1];
    } else {
      o.x = this.longitudeAtX(i);
      o.y = this.latitudeAtY(j);
    }
    return o;
  };
  Field2.prototype.checkFields = function() {
    return this.isFields;
  };
  Field2.prototype.startBatchInterpolate = function(width, height, unproject) {
  };
  return Field2;
}();
var defaultOptions = {
  globalAlpha: 0.9,
  lineWidth: 1,
  colorScale: "#fff",
  velocityScale: 1 / 25,
  maxAge: 90,
  paths: 800,
  frameRate: 20,
  useCoordsDraw: true,
  gpet: true
};
function indexFor(m, min, max, colorScale) {
  return Math.max(0, Math.min(colorScale.length - 1, Math.round((m - min) / (max - min) * (colorScale.length - 1))));
}
var BaseLayer = function() {
  function BaseLayer2(ctx, options, field) {
    this.particles = [];
    this.generated = false;
    this.ctx = ctx;
    if (!this.ctx) {
      throw new Error("ctx error");
    }
    this.animate = this.animate.bind(this);
    this.setOptions(options);
    if (field) {
      this.updateData(field);
    }
  }
  BaseLayer2.prototype.setOptions = function(options) {
    this.options = Object.assign({}, defaultOptions, options);
    var _a = this.ctx.canvas, width = _a.width, height = _a.height;
    if ("particleAge" in options && !("maxAge" in options) && isNumber(this.options.particleAge)) {
      this.options.maxAge = this.options.particleAge;
    }
    if ("particleMultiplier" in options && !("paths" in options) && isNumber(this.options.particleMultiplier)) {
      this.options.paths = Math.round(width * height * this.options.particleMultiplier);
    }
    this.prerender();
  };
  BaseLayer2.prototype.getOptions = function() {
    return this.options;
  };
  BaseLayer2.prototype.updateData = function(field) {
    this.field = field;
    if (!this.generated) {
      return;
    }
    this.particles = this.prepareParticlePaths();
  };
  BaseLayer2.prototype.moveParticles = function() {
    var _a = this.ctx.canvas, width = _a.width, height = _a.height;
    var particles = this.particles;
    var maxAge = this.options.maxAge;
    var optVelocityScale = isFunction(this.options.velocityScale) ? this.options.velocityScale() : this.options.velocityScale;
    var velocityScale = optVelocityScale;
    var i = 0;
    var len = particles.length;
    for (; i < len; i++) {
      var particle = particles[i];
      if (particle.age > maxAge) {
        particle.age = 0;
        this.field.randomize(particle, width, height, this.unproject);
      }
      var x = particle.x;
      var y = particle.y;
      var vector = this.field.interpolatedValueAt(x, y);
      if (vector === null) {
        particle.age = maxAge;
      } else {
        var xt = x + vector.u * velocityScale;
        var yt = y + vector.v * velocityScale;
        if (this.field.hasValueAt(xt, yt)) {
          particle.xt = xt;
          particle.yt = yt;
          particle.m = vector.m;
        } else {
          particle.x = xt;
          particle.y = yt;
          particle.age = maxAge;
        }
      }
      particle.age++;
    }
  };
  BaseLayer2.prototype.fadeIn = function() {
    var prev = this.ctx.globalCompositeOperation;
    this.ctx.globalCompositeOperation = "destination-in";
    this.ctx.fillRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
    this.ctx.globalCompositeOperation = prev;
  };
  BaseLayer2.prototype.drawParticles = function() {
    var _a;
    var particles = this.particles;
    this.fadeIn();
    this.ctx.globalAlpha = this.options.globalAlpha;
    this.ctx.fillStyle = "rgba(0, 0, 0, " + this.options.globalAlpha + ")";
    this.ctx.lineWidth = isNumber(this.options.lineWidth) ? this.options.lineWidth : 1;
    this.ctx.strokeStyle = isString(this.options.colorScale) ? this.options.colorScale : "#fff";
    var i = 0;
    var len = particles.length;
    if (this.field && len > 0) {
      var min = void 0;
      var max = void 0;
      if (isValide(this.options.minVelocity) && isValide(this.options.maxVelocity)) {
        min = this.options.minVelocity;
        max = this.options.maxVelocity;
      } else {
        _a = this.field.range, min = _a[0], max = _a[1];
      }
      for (; i < len; i++) {
        this[this.options.useCoordsDraw ? "drawCoordsParticle" : "drawPixelParticle"](particles[i], min, max);
      }
    }
  };
  BaseLayer2.prototype.drawPixelParticle = function(particle, min, max) {
    var pointPrev = [particle.x, particle.y];
    var pointNext = [particle.xt, particle.yt];
    if (pointNext && pointPrev && isValide(pointNext[0]) && isValide(pointNext[1]) && isValide(pointPrev[0]) && isValide(pointPrev[1]) && particle.age <= this.options.maxAge) {
      this.ctx.beginPath();
      this.ctx.moveTo(pointPrev[0], pointPrev[1]);
      this.ctx.lineTo(pointNext[0], pointNext[1]);
      if (isFunction(this.options.colorScale)) {
        this.ctx.strokeStyle = this.options.colorScale(particle.m);
      } else if (Array.isArray(this.options.colorScale)) {
        var colorIdx = indexFor(particle.m, min, max, this.options.colorScale);
        this.ctx.strokeStyle = this.options.colorScale[colorIdx];
      }
      if (isFunction(this.options.lineWidth)) {
        this.ctx.lineWidth = this.options.lineWidth(particle.m);
      }
      particle.x = particle.xt;
      particle.y = particle.yt;
      this.ctx.stroke();
    }
  };
  BaseLayer2.prototype.drawCoordsParticle = function(particle, min, max) {
    var source = [particle.x, particle.y];
    var target = [particle.xt, particle.yt];
    if (target && source && isValide(target[0]) && isValide(target[1]) && isValide(source[0]) && isValide(source[1]) && this.intersectsCoordinate(target) && particle.age <= this.options.maxAge) {
      var pointPrev = this.project(source);
      var pointNext = this.project(target);
      if (pointPrev && pointNext) {
        this.ctx.beginPath();
        this.ctx.moveTo(pointPrev[0], pointPrev[1]);
        this.ctx.lineTo(pointNext[0], pointNext[1]);
        particle.x = particle.xt;
        particle.y = particle.yt;
        if (isFunction(this.options.colorScale)) {
          this.ctx.strokeStyle = this.options.colorScale(particle.m);
        } else if (Array.isArray(this.options.colorScale)) {
          var colorIdx = indexFor(particle.m, min, max, this.options.colorScale);
          this.ctx.strokeStyle = this.options.colorScale[colorIdx];
        }
        if (isFunction(this.options.lineWidth)) {
          this.ctx.lineWidth = this.options.lineWidth(particle.m);
        }
        this.ctx.stroke();
      }
    }
  };
  BaseLayer2.prototype.prepareParticlePaths = function() {
    var _a = this.ctx.canvas, width = _a.width, height = _a.height;
    var particleCount = typeof this.options.paths === "function" ? this.options.paths(this) : this.options.paths;
    var particles = [];
    if (!this.field) {
      return [];
    }
    if ("startBatchInterpolate" in this.field) {
      this.field.startBatchInterpolate(width, height, this.unproject);
    }
    var i = 0;
    for (; i < particleCount; i++) {
      particles.push(this.field.randomize({
        age: this.randomize()
      }, width, height, this.unproject));
    }
    return particles;
  };
  BaseLayer2.prototype.randomize = function() {
    return Math.floor(Math.random() * this.options.maxAge);
  };
  BaseLayer2.prototype.project = function() {
    var arguments$1 = arguments;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments$1[_i];
    }
    throw new Error("project must be overriden");
  };
  BaseLayer2.prototype.unproject = function() {
    var arguments$1 = arguments;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments$1[_i];
    }
    throw new Error("unproject must be overriden");
  };
  BaseLayer2.prototype.intersectsCoordinate = function(coordinates) {
    throw new Error("must be overriden");
  };
  BaseLayer2.prototype.clearCanvas = function() {
    this.stop();
    this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
    this.forceStop = false;
  };
  BaseLayer2.prototype.start = function() {
    this.starting = true;
    this.forceStop = false;
    this._then = Date.now();
    this.animate();
  };
  BaseLayer2.prototype.stop = function() {
    cancelAnimationFrame(this.animationLoop);
    this.starting = false;
    this.forceStop = true;
  };
  BaseLayer2.prototype.animate = function() {
    if (this.animationLoop) {
      cancelAnimationFrame(this.animationLoop);
    }
    this.animationLoop = requestAnimationFrame(this.animate);
    var now = Date.now();
    var delta = now - this._then;
    if (delta > this.options.frameRate) {
      this._then = now - delta % this.options.frameRate;
      this.render();
    }
  };
  BaseLayer2.prototype.prerender = function() {
    this.generated = false;
    if (!this.field) {
      return;
    }
    this.particles = this.prepareParticlePaths();
    this.generated = true;
    if (!this.starting && !this.forceStop) {
      this.starting = true;
      this._then = Date.now();
      this.animate();
    }
  };
  BaseLayer2.prototype.render = function() {
    this.moveParticles();
    this.drawParticles();
    this.postrender();
  };
  BaseLayer2.prototype.postrender = function() {
  };
  BaseLayer2.Field = Field;
  return BaseLayer2;
}();
var ViewHint = {
  ANIMATING: 0,
  INTERACTING: 1
};
function transform2D(flatCoordinates, offset, end, stride, transform2, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var i = 0;
  for (var j = offset; j < end; j += stride) {
    var x = flatCoordinates[j];
    var y = flatCoordinates[j + 1];
    dest[i++] = transform2[0] * x + transform2[2] * y + transform2[4];
    dest[i++] = transform2[1] * x + transform2[3] * y + transform2[5];
  }
  if (opt_dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}
var Render = function() {
  function Render2() {
    this.executors = {};
    this.renderedTransform_ = create();
  }
  Render2.prototype.execute = function(context, index, frameState, transform2, renderedTransform, opt, data) {
    if (this.executors[index]) {
      var wind = this.executors[index];
      wind.project = this.getPixelFromCoordinateInternal.bind(this, frameState, transform2);
      wind.unproject = this.getCoordinateFromPixel.bind(this, frameState);
      wind.intersectsCoordinate = this.intersectsCoordinate.bind(this, frameState);
      wind.prerender();
      wind.render();
    } else {
      var wind = new BaseLayer(context, opt, data);
      this.executors[index] = wind;
      wind.project = this.getPixelFromCoordinateInternal.bind(this, frameState, transform2);
      wind.unproject = this.getCoordinateFromPixel.bind(this, frameState);
      wind.intersectsCoordinate = this.intersectsCoordinate.bind(this, frameState);
      wind.postrender = function() {
      };
      wind.prerender();
    }
  };
  Render2.prototype.setOptions = function(options) {
    var _this = this;
    Object.keys(this.executors).forEach(function(key) {
      var wind = _this.executors[key];
      if (wind) {
        wind.setOptions(options);
      }
    });
  };
  Render2.prototype.setData = function(field) {
    var _this = this;
    Object.keys(this.executors).forEach(function(key) {
      var wind = _this.executors[key];
      if (wind) {
        wind.updateData(field);
      }
    });
  };
  Render2.prototype.repeatWorld = function(coordinates, pixelCoordinates, transform2) {
    var pixel;
    if (pixelCoordinates && equals(transform2, this.renderedTransform_)) {
      pixel = pixelCoordinates;
    } else {
      if (!pixelCoordinates) {
        pixelCoordinates = [];
      }
      pixel = transform2D(coordinates, 0, coordinates.length, 2, transform2, pixelCoordinates);
      setFromArray(this.renderedTransform_, transform2);
    }
    return pixel;
  };
  Render2.prototype.getPixelFromCoordinateInternal = function(frameState, transform$1, coordinate) {
    var viewState = frameState.viewState;
    var pixelRatio = frameState.pixelRatio;
    var point = transform(coordinate, "EPSG:4326", viewState.projection);
    var viewCoordinate = fromUserCoordinate(point, viewState.projection);
    if (!frameState) {
      return null;
    } else {
      var pixelCoordinates = apply(frameState.coordinateToPixelTransform, viewCoordinate.slice(0, 2));
      var pixel = this.repeatWorld(viewCoordinate.slice(0, 2), pixelCoordinates, transform$1);
      return [
        pixel[0] * pixelRatio,
        pixel[1] * pixelRatio
      ];
    }
  };
  Render2.prototype.getCoordinateFromPixel = function(frameState, pixel) {
    var viewState = frameState.viewState;
    if (!frameState) {
      return null;
    } else {
      var viewCoordinate = apply(frameState.pixelToCoordinateTransform, pixel.slice(0, 2));
      var coordinate = toUserCoordinate(viewCoordinate, viewState.projection);
      var point = transform(coordinate, viewState.projection, "EPSG:4326");
      return [
        point[0],
        point[1]
      ];
    }
  };
  Render2.prototype.intersectsCoordinate = function(frameState, coordinate) {
    var viewState = frameState.viewState;
    var point = transform(coordinate, "EPSG:4326", viewState.projection);
    var viewCoordinate = fromUserCoordinate(point, viewState.projection);
    return containsCoordinate(frameState.extent, viewCoordinate.slice(0, 2));
  };
  return Render2;
}();
var WindLayerRender = function(_super) {
  __extends(WindLayerRender2, _super);
  function WindLayerRender2(layer) {
    var _this = _super.call(this, layer) || this;
    _this.oRender = new Render();
    return _this;
  }
  WindLayerRender2.prototype.useContainer = function(target, transform2, opacity) {
    _super.prototype.useContainer.call(this, null, transform2, opacity);
  };
  WindLayerRender2.prototype.prepareFrame = function(frameState) {
    var layerState = frameState.layerStatesArray[frameState.layerIndex];
    var viewState = frameState.viewState;
    var hints = frameState.viewHints;
    var renderedExtent = frameState.extent;
    if (layerState.extent !== void 0) {
      renderedExtent = getIntersection(renderedExtent, fromUserExtent(layerState.extent, viewState.projection));
    }
    if (!hints[ViewHint.ANIMATING] && !frameState.animate && !hints[ViewHint.INTERACTING] && !isEmpty(renderedExtent)) {
      return true;
    } else {
      var layer = this.getLayer();
      return layer.get("forceRender");
    }
  };
  WindLayerRender2.prototype.renderFrame = function(frameState, target) {
    var layerState = frameState.layerStatesArray[frameState.layerIndex];
    var pixelRatio = frameState.pixelRatio;
    var viewState = frameState.viewState;
    var projection = viewState.projection;
    var size = frameState.size;
    var width = Math.round(size[0] * pixelRatio);
    var height = Math.round(size[1] * pixelRatio);
    makeScale(this.pixelTransform, 1 / pixelRatio, 1 / pixelRatio);
    makeInverse(this.inversePixelTransform, this.pixelTransform);
    var canvasTransform = toString2(this.pixelTransform);
    this.useContainer(target, canvasTransform, layerState.opacity);
    var context = this.context;
    var canvas = context.canvas;
    if (canvas.width != width || canvas.height != height) {
      canvas.width = width;
      canvas.height = height;
      if (canvas.style.transform !== canvasTransform) {
        canvas.style.transform = canvasTransform;
      }
    } else if (!this.containerReused) {
      context.clearRect(0, 0, width, height);
    }
    this.preRender(context, frameState);
    var clipped = false;
    if (layerState.extent) {
      var layerExtent = fromUserExtent(layerState.extent, viewState.projection);
      clipped = !containsExtent(layerExtent, frameState.extent) && intersects(layerExtent, frameState.extent);
      if (clipped) {
        this.clipUnrotated(context, frameState, layerExtent);
      }
    }
    var extent = frameState.extent;
    var center = viewState.center;
    var resolution = viewState.resolution;
    var rotation = viewState.rotation;
    var projectionExtent = projection.getExtent();
    var layer = this.getLayer();
    var opt = layer.getWindOptions();
    var data = layer.getData();
    var transformOrigin = this.getRenderTransform(center, resolution, rotation, pixelRatio, width, height, 0);
    this.oRender.execute(this.context, 0, frameState, transformOrigin, transformOrigin, opt, data);
    if (clipped) {
      context.restore();
    }
    this.postRender(context, frameState);
    var opacity = layerState.opacity;
    var container = this.container;
    if (container !== null && opacity !== parseFloat(container.style.opacity)) {
      container.style.opacity = opacity === 1 ? "" : opacity;
    }
    return this.container;
  };
  return WindLayerRender2;
}(Layer_default2);
var _options = {
  forceRender: true,
  windOptions: {}
};
var WindLayer = function(_super) {
  __extends(WindLayer2, _super);
  function WindLayer2(data, options) {
    var _this = this;
    var opt = assign({}, _options, options);
    _this = _super.call(this, opt) || this;
    _this.field = null;
    _this.options = opt;
    _this.pickWindOptions();
    _this._map = opt.map || null;
    if (data) {
      _this.setData(data);
    }
    return _this;
  }
  WindLayer2.prototype.render = function(frameState, target) {
    var layerRenderer = this.getRenderer();
    if (layerRenderer.prepareFrame(frameState)) {
      return layerRenderer.renderFrame(frameState, target);
    }
  };
  WindLayer2.prototype.getRenderer = function() {
    if (!this.renderer_) {
      this.renderer_ = this.createRenderer();
    }
    return this.renderer_;
  };
  WindLayer2.prototype.getWrapX = function() {
    return this.get("wrapX");
  };
  WindLayer2.prototype.hasRenderer = function() {
    return !!this.renderer_;
  };
  WindLayer2.prototype.createRenderer = function() {
    return new WindLayerRender(this);
  };
  WindLayer2.prototype.pickWindOptions = function() {
    var _this = this;
    Object.keys(defaultOptions).forEach(function(key) {
      if (key in _this.options) {
        if (_this.options.windOptions === void 0) {
          _this.options.windOptions = {};
        }
        _this.options.windOptions[key] = _this.options[key];
      }
    });
  };
  WindLayer2.prototype.getData = function() {
    return this.field;
  };
  WindLayer2.prototype.setData = function(data) {
    if (data && data.checkFields && data.checkFields()) {
      this.field = data;
    } else if (isArray(data)) {
      this.field = formatData(data);
    } else {
      console.error("Illegal data");
    }
    var renderer = this.getRenderer();
    if (renderer && renderer.oRender) {
      renderer.oRender.setData(data);
    }
    return this;
  };
  WindLayer2.prototype.updateParams = function(options) {
    if (options === void 0) {
      options = {};
    }
    warnLog("will move to setWindOptions");
    this.setWindOptions(options);
    return this;
  };
  WindLayer2.prototype.getParams = function() {
    warnLog("will move to getWindOptions");
    return this.getWindOptions();
  };
  WindLayer2.prototype.setWindOptions = function(options) {
    var beforeOptions = this.options.windOptions || {};
    this.options = assign(this.options, {
      windOptions: assign(beforeOptions, options || {})
    });
    var renderer = this.getRenderer();
    if (renderer && renderer.oRender) {
      var windOptions = this.options.windOptions;
      renderer.oRender.setOptions(windOptions);
    }
  };
  WindLayer2.prototype.getWindOptions = function() {
    return this.options.windOptions || {};
  };
  return WindLayer2;
}(Layer_default);
export {
  Field,
  WindLayer
};
/*!
 * author: sakitam-fdd <smilefdd@gmail.com> 
 * ol-wind v1.1.1-alpha.1
 * build-time: 2021-3-30 18:18
 * LICENSE: MIT
 * (c) 2017-2021 https://github.com/sakitam-fdd/wind-layer#readme
 */
/*!
 * author: sakitam-fdd <smilefdd@gmail.com> 
 * wind-core v1.1.1-alpha.1
 * build-time: 2021-3-30 18:18
 * LICENSE: MIT
 * (c) 2017-2021 https://github.com/sakitam-fdd/wind-layer#readme
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
//# sourceMappingURL=ol-wind.js.map
